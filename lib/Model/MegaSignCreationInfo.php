<?php
/**
 * MegaSignCreationInfo
 *
 * PHP version 5
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.0
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Swagger\Client\Model;

use \ArrayAccess;
use \Swagger\Client\ObjectSerializer;

/**
 * MegaSignCreationInfo Class Doc Comment
 *
 * @category Class
 * @package  Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class MegaSignCreationInfo implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'MegaSignCreationInfo';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'ccs' => '\Swagger\Client\Model\MegaSignCcInfo[]',
        'child_agreements_info' => '\Swagger\Client\Model\ChildAgreementsInfo',
        'created_date' => '\DateTime',
        'expiration_time' => '\Swagger\Client\Model\\DateTime',
        'external_id' => '\Swagger\Client\Model\ExternalId',
        'file_infos' => '\Swagger\Client\Model\FileInfo[]',
        'first_reminder_delay' => 'int',
        'id' => 'string',
        'locale' => 'string',
        'message' => 'string',
        'name' => 'string',
        'post_sign_option' => '\Swagger\Client\Model\PostSignOption',
        'reminder_frequency' => 'string',
        'security_option' => '\Swagger\Client\Model\MegaSignSecurityOption',
        'sender_email' => 'string',
        'signature_type' => 'string',
        'state' => 'string',
        'status' => 'string',
        'vaulting_info' => '\Swagger\Client\Model\VaultingInfo'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'ccs' => null,
        'child_agreements_info' => null,
        'created_date' => 'date',
        'expiration_time' => null,
        'external_id' => null,
        'file_infos' => null,
        'first_reminder_delay' => null,
        'id' => null,
        'locale' => null,
        'message' => null,
        'name' => null,
        'post_sign_option' => null,
        'reminder_frequency' => null,
        'security_option' => null,
        'sender_email' => null,
        'signature_type' => null,
        'state' => null,
        'status' => null,
        'vaulting_info' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'ccs' => 'ccs',
        'child_agreements_info' => 'childAgreementsInfo',
        'created_date' => 'createdDate',
        'expiration_time' => 'expirationTime',
        'external_id' => 'externalId',
        'file_infos' => 'fileInfos',
        'first_reminder_delay' => 'firstReminderDelay',
        'id' => 'id',
        'locale' => 'locale',
        'message' => 'message',
        'name' => 'name',
        'post_sign_option' => 'postSignOption',
        'reminder_frequency' => 'reminderFrequency',
        'security_option' => 'securityOption',
        'sender_email' => 'senderEmail',
        'signature_type' => 'signatureType',
        'state' => 'state',
        'status' => 'status',
        'vaulting_info' => 'vaultingInfo'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'ccs' => 'setCcs',
        'child_agreements_info' => 'setChildAgreementsInfo',
        'created_date' => 'setCreatedDate',
        'expiration_time' => 'setExpirationTime',
        'external_id' => 'setExternalId',
        'file_infos' => 'setFileInfos',
        'first_reminder_delay' => 'setFirstReminderDelay',
        'id' => 'setId',
        'locale' => 'setLocale',
        'message' => 'setMessage',
        'name' => 'setName',
        'post_sign_option' => 'setPostSignOption',
        'reminder_frequency' => 'setReminderFrequency',
        'security_option' => 'setSecurityOption',
        'sender_email' => 'setSenderEmail',
        'signature_type' => 'setSignatureType',
        'state' => 'setState',
        'status' => 'setStatus',
        'vaulting_info' => 'setVaultingInfo'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'ccs' => 'getCcs',
        'child_agreements_info' => 'getChildAgreementsInfo',
        'created_date' => 'getCreatedDate',
        'expiration_time' => 'getExpirationTime',
        'external_id' => 'getExternalId',
        'file_infos' => 'getFileInfos',
        'first_reminder_delay' => 'getFirstReminderDelay',
        'id' => 'getId',
        'locale' => 'getLocale',
        'message' => 'getMessage',
        'name' => 'getName',
        'post_sign_option' => 'getPostSignOption',
        'reminder_frequency' => 'getReminderFrequency',
        'security_option' => 'getSecurityOption',
        'sender_email' => 'getSenderEmail',
        'signature_type' => 'getSignatureType',
        'state' => 'getState',
        'status' => 'getStatus',
        'vaulting_info' => 'getVaultingInfo'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const REMINDER_FREQUENCY_DAILY_UNTIL_SIGNED = 'DAILY_UNTIL_SIGNED';
    const REMINDER_FREQUENCY_WEEKLY_UNTIL_SIGNED = 'WEEKLY_UNTIL_SIGNED';
    const SIGNATURE_TYPE_ESIGN = 'ESIGN';
    const SIGNATURE_TYPE_WRITTEN = 'WRITTEN';
    const STATE_IN_PROCESS = 'IN_PROCESS';
    const STATUS_AUTHORING = 'AUTHORING';
    const STATUS_IN_PROCESS = 'IN_PROCESS';
    const STATUS_CANCELLED = 'CANCELLED';
    const STATUS_COMPLETED = 'COMPLETED';
    const STATUS_EXPIRED = 'EXPIRED';
    const STATUS_PREFILL = 'PREFILL';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getReminderFrequencyAllowableValues()
    {
        return [
            self::REMINDER_FREQUENCY_DAILY_UNTIL_SIGNED,
            self::REMINDER_FREQUENCY_WEEKLY_UNTIL_SIGNED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSignatureTypeAllowableValues()
    {
        return [
            self::SIGNATURE_TYPE_ESIGN,
            self::SIGNATURE_TYPE_WRITTEN,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_IN_PROCESS,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_AUTHORING,
            self::STATUS_IN_PROCESS,
            self::STATUS_CANCELLED,
            self::STATUS_COMPLETED,
            self::STATUS_EXPIRED,
            self::STATUS_PREFILL,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['ccs'] = isset($data['ccs']) ? $data['ccs'] : null;
        $this->container['child_agreements_info'] = isset($data['child_agreements_info']) ? $data['child_agreements_info'] : null;
        $this->container['created_date'] = isset($data['created_date']) ? $data['created_date'] : null;
        $this->container['expiration_time'] = isset($data['expiration_time']) ? $data['expiration_time'] : null;
        $this->container['external_id'] = isset($data['external_id']) ? $data['external_id'] : null;
        $this->container['file_infos'] = isset($data['file_infos']) ? $data['file_infos'] : null;
        $this->container['first_reminder_delay'] = isset($data['first_reminder_delay']) ? $data['first_reminder_delay'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['locale'] = isset($data['locale']) ? $data['locale'] : null;
        $this->container['message'] = isset($data['message']) ? $data['message'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['post_sign_option'] = isset($data['post_sign_option']) ? $data['post_sign_option'] : null;
        $this->container['reminder_frequency'] = isset($data['reminder_frequency']) ? $data['reminder_frequency'] : null;
        $this->container['security_option'] = isset($data['security_option']) ? $data['security_option'] : null;
        $this->container['sender_email'] = isset($data['sender_email']) ? $data['sender_email'] : null;
        $this->container['signature_type'] = isset($data['signature_type']) ? $data['signature_type'] : null;
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
        $this->container['vaulting_info'] = isset($data['vaulting_info']) ? $data['vaulting_info'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getReminderFrequencyAllowableValues();
        if (!is_null($this->container['reminder_frequency']) && !in_array($this->container['reminder_frequency'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'reminder_frequency', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getSignatureTypeAllowableValues();
        if (!is_null($this->container['signature_type']) && !in_array($this->container['signature_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'signature_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'state', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets ccs
     *
     * @return \Swagger\Client\Model\MegaSignCcInfo[]
     */
    public function getCcs()
    {
        return $this->container['ccs'];
    }

    /**
     * Sets ccs
     *
     * @param \Swagger\Client\Model\MegaSignCcInfo[] $ccs A list of one or more CCs that will be copied in the megasign transaction. The CCs will each receive an email at the beginning of the transaction and also when the final document is signed. The email addresses will also receive a copy of the document, attached as a PDF file
     *
     * @return $this
     */
    public function setCcs($ccs)
    {
        $this->container['ccs'] = $ccs;

        return $this;
    }

    /**
     * Gets child_agreements_info
     *
     * @return \Swagger\Client\Model\ChildAgreementsInfo
     */
    public function getChildAgreementsInfo()
    {
        return $this->container['child_agreements_info'];
    }

    /**
     * Sets child_agreements_info
     *
     * @param \Swagger\Client\Model\ChildAgreementsInfo $child_agreements_info Info corresponding to each child agreement of the megaSign
     *
     * @return $this
     */
    public function setChildAgreementsInfo($child_agreements_info)
    {
        $this->container['child_agreements_info'] = $child_agreements_info;

        return $this;
    }

    /**
     * Gets created_date
     *
     * @return \DateTime
     */
    public function getCreatedDate()
    {
        return $this->container['created_date'];
    }

    /**
     * Sets created_date
     *
     * @param \DateTime $created_date Date when megasign was created. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time
     *
     * @return $this
     */
    public function setCreatedDate($created_date)
    {
        $this->container['created_date'] = $created_date;

        return $this;
    }

    /**
     * Gets expiration_time
     *
     * @return \Swagger\Client\Model\\DateTime
     */
    public function getExpirationTime()
    {
        return $this->container['expiration_time'];
    }

    /**
     * Sets expiration_time
     *
     * @param \Swagger\Client\Model\\DateTime $expiration_time Time after which Agreement expires and needs to be signed before it. Format should be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time. Should not be provided in offline agreement creation.
     *
     * @return $this
     */
    public function setExpirationTime($expiration_time)
    {
        $this->container['expiration_time'] = $expiration_time;

        return $this;
    }

    /**
     * Gets external_id
     *
     * @return \Swagger\Client\Model\ExternalId
     */
    public function getExternalId()
    {
        return $this->container['external_id'];
    }

    /**
     * Sets external_id
     *
     * @param \Swagger\Client\Model\ExternalId $external_id An arbitrary value from your system, which can be specified at sending time and then later returned or queried
     *
     * @return $this
     */
    public function setExternalId($external_id)
    {
        $this->container['external_id'] = $external_id;

        return $this;
    }

    /**
     * Gets file_infos
     *
     * @return \Swagger\Client\Model\FileInfo[]
     */
    public function getFileInfos()
    {
        return $this->container['file_infos'];
    }

    /**
     * Sets file_infos
     *
     * @param \Swagger\Client\Model\FileInfo[] $file_infos A list of one or more files (or references to files) that will be sent out for signature. If more than one file is provided, they will be combined into one PDF before being sent out. Note: Only one of the four parameters in every FileInfo object must be specified
     *
     * @return $this
     */
    public function setFileInfos($file_infos)
    {
        $this->container['file_infos'] = $file_infos;

        return $this;
    }

    /**
     * Gets first_reminder_delay
     *
     * @return int
     */
    public function getFirstReminderDelay()
    {
        return $this->container['first_reminder_delay'];
    }

    /**
     * Sets first_reminder_delay
     *
     * @param int $first_reminder_delay Integer which specifies the delay in hours before sending the first reminder.<br>This is an optional field. The minimum value allowed is 1 hour and the maximum value can’t be more than the difference of agreement creation and expiry time of the agreement in hours.<br>If this is not specified but the reminder frequency is specified, then the first reminder will be sent based on frequency.<br>i.e. if the reminder is created with frequency specified as daily, the firstReminderDelay will be 24 hours
     *
     * @return $this
     */
    public function setFirstReminderDelay($first_reminder_delay)
    {
        $this->container['first_reminder_delay'] = $first_reminder_delay;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id The unique identifier of megasign
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets locale
     *
     * @return string
     */
    public function getLocale()
    {
        return $this->container['locale'];
    }

    /**
     * Sets locale
     *
     * @param string $locale The locale associated with this agreement - specifies the language for the signing page and emails, for example en_US or fr_FR. If none specified, defaults to the language configured for the agreement sender
     *
     * @return $this
     */
    public function setLocale($locale)
    {
        $this->container['locale'] = $locale;

        return $this;
    }

    /**
     * Gets message
     *
     * @return string
     */
    public function getMessage()
    {
        return $this->container['message'];
    }

    /**
     * Sets message
     *
     * @param string $message An optional message to the participants, describing what is being sent or why their signature is required
     *
     * @return $this
     */
    public function setMessage($message)
    {
        $this->container['message'] = $message;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name of the agreement that will be used to identify it, in emails, website and other places
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets post_sign_option
     *
     * @return \Swagger\Client\Model\PostSignOption
     */
    public function getPostSignOption()
    {
        return $this->container['post_sign_option'];
    }

    /**
     * Sets post_sign_option
     *
     * @param \Swagger\Client\Model\PostSignOption $post_sign_option URL and associated properties for the success page the user will be taken to after completing the signing process
     *
     * @return $this
     */
    public function setPostSignOption($post_sign_option)
    {
        $this->container['post_sign_option'] = $post_sign_option;

        return $this;
    }

    /**
     * Gets reminder_frequency
     *
     * @return string
     */
    public function getReminderFrequency()
    {
        return $this->container['reminder_frequency'];
    }

    /**
     * Sets reminder_frequency
     *
     * @param string $reminder_frequency Optional parameter that sets how often you want to send reminders to the participants. If it is not specified, the default frequency set for the account will be used
     *
     * @return $this
     */
    public function setReminderFrequency($reminder_frequency)
    {
        $allowedValues = $this->getReminderFrequencyAllowableValues();
        if (!is_null($reminder_frequency) && !in_array($reminder_frequency, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'reminder_frequency', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['reminder_frequency'] = $reminder_frequency;

        return $this;
    }

    /**
     * Gets security_option
     *
     * @return \Swagger\Client\Model\MegaSignSecurityOption
     */
    public function getSecurityOption()
    {
        return $this->container['security_option'];
    }

    /**
     * Sets security_option
     *
     * @param \Swagger\Client\Model\MegaSignSecurityOption $security_option Optional security parameters for the megasign
     *
     * @return $this
     */
    public function setSecurityOption($security_option)
    {
        $this->container['security_option'] = $security_option;

        return $this;
    }

    /**
     * Gets sender_email
     *
     * @return string
     */
    public function getSenderEmail()
    {
        return $this->container['sender_email'];
    }

    /**
     * Sets sender_email
     *
     * @param string $sender_email Email of agreement sender. Only provided in GET. Can not be provided in POST/PUT request. If provided in POST/PUT, it will be ignored
     *
     * @return $this
     */
    public function setSenderEmail($sender_email)
    {
        $this->container['sender_email'] = $sender_email;

        return $this;
    }

    /**
     * Gets signature_type
     *
     * @return string
     */
    public function getSignatureType()
    {
        return $this->container['signature_type'];
    }

    /**
     * Sets signature_type
     *
     * @param string $signature_type Specifies the type of signature you would like to request - written or e-signature. The possible values are <br> ESIGN : Agreement needs to be signed electronically <br>, WRITTEN : Agreement will be signed using handwritten signature and signed document will be uploaded into the system
     *
     * @return $this
     */
    public function setSignatureType($signature_type)
    {
        $allowedValues = $this->getSignatureTypeAllowableValues();
        if (!is_null($signature_type) && !in_array($signature_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'signature_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['signature_type'] = $signature_type;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state State of the Megasign
     *
     * @return $this
     */
    public function setState($state)
    {
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($state) && !in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'state', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status Status of the Megasign
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }

    /**
     * Gets vaulting_info
     *
     * @return \Swagger\Client\Model\VaultingInfo
     */
    public function getVaultingInfo()
    {
        return $this->container['vaulting_info'];
    }

    /**
     * Sets vaulting_info
     *
     * @param \Swagger\Client\Model\VaultingInfo $vaulting_info Vaulting properties that allows Adobe Sign to securely store documents with a vault provider
     *
     * @return $this
     */
    public function setVaultingInfo($vaulting_info)
    {
        $this->container['vaulting_info'] = $vaulting_info;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


