<?php
/**
 * WebhookInfo
 *
 * PHP version 5
 *
 * @category Class
 * @package  Adobe\ESign
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.4
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Adobe\ESign\Model;

use \ArrayAccess;
use \Adobe\ESign\ObjectSerializer;

/**
 * WebhookInfo Class Doc Comment
 *
 * @category Class
 * @package  Adobe\ESign
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class WebhookInfo implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'WebhookInfo';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'resourceId' => 'string',
        'webhookUrlInfo' => '\Adobe\ESign\Model\WebhookUrlInfo',
        'webhookConditionalParams' => '\Adobe\ESign\Model\WebhookConditionalParams',
        'created' => '\DateTime',
        'webhookSubscriptionEvents' => 'string[]',
        'applicationDisplayName' => 'string',
        'scope' => 'string',
        'name' => 'string',
        'id' => 'string',
        'lastModified' => '\DateTime',
        'state' => 'string',
        'applicationName' => 'string',
        'resourceType' => 'string',
        'status' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'resourceId' => null,
        'webhookUrlInfo' => null,
        'webhookConditionalParams' => null,
        'created' => 'date',
        'webhookSubscriptionEvents' => null,
        'applicationDisplayName' => null,
        'scope' => null,
        'name' => null,
        'id' => null,
        'lastModified' => 'date',
        'state' => null,
        'applicationName' => null,
        'resourceType' => null,
        'status' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'resourceId' => 'resourceId',
        'webhookUrlInfo' => 'webhookUrlInfo',
        'webhookConditionalParams' => 'webhookConditionalParams',
        'created' => 'created',
        'webhookSubscriptionEvents' => 'webhookSubscriptionEvents',
        'applicationDisplayName' => 'applicationDisplayName',
        'scope' => 'scope',
        'name' => 'name',
        'id' => 'id',
        'lastModified' => 'lastModified',
        'state' => 'state',
        'applicationName' => 'applicationName',
        'resourceType' => 'resourceType',
        'status' => 'status'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'resourceId' => 'setResourceId',
        'webhookUrlInfo' => 'setWebhookUrlInfo',
        'webhookConditionalParams' => 'setWebhookConditionalParams',
        'created' => 'setCreated',
        'webhookSubscriptionEvents' => 'setWebhookSubscriptionEvents',
        'applicationDisplayName' => 'setApplicationDisplayName',
        'scope' => 'setScope',
        'name' => 'setName',
        'id' => 'setId',
        'lastModified' => 'setLastModified',
        'state' => 'setState',
        'applicationName' => 'setApplicationName',
        'resourceType' => 'setResourceType',
        'status' => 'setStatus'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'resourceId' => 'getResourceId',
        'webhookUrlInfo' => 'getWebhookUrlInfo',
        'webhookConditionalParams' => 'getWebhookConditionalParams',
        'created' => 'getCreated',
        'webhookSubscriptionEvents' => 'getWebhookSubscriptionEvents',
        'applicationDisplayName' => 'getApplicationDisplayName',
        'scope' => 'getScope',
        'name' => 'getName',
        'id' => 'getId',
        'lastModified' => 'getLastModified',
        'state' => 'getState',
        'applicationName' => 'getApplicationName',
        'resourceType' => 'getResourceType',
        'status' => 'getStatus'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_CREATED = 'AGREEMENT_CREATED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_ACTION_DELEGATED = 'AGREEMENT_ACTION_DELEGATED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_RECALLED = 'AGREEMENT_RECALLED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_REJECTED = 'AGREEMENT_REJECTED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_EXPIRED = 'AGREEMENT_EXPIRED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_ACTION_COMPLETED = 'AGREEMENT_ACTION_COMPLETED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_WORKFLOW_COMPLETED = 'AGREEMENT_WORKFLOW_COMPLETED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_EMAIL_VIEWED = 'AGREEMENT_EMAIL_VIEWED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_MODIFIED = 'AGREEMENT_MODIFIED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_SHARED = 'AGREEMENT_SHARED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_VAULTED = 'AGREEMENT_VAULTED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_ACTION_REQUESTED = 'AGREEMENT_ACTION_REQUESTED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_ACTION_REPLACED_SIGNER = 'AGREEMENT_ACTION_REPLACED_SIGNER';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_AUTO_CANCELLED_CONVERSION_PROBLEM = 'AGREEMENT_AUTO_CANCELLED_CONVERSION_PROBLEM';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_DOCUMENTS_DELETED = 'AGREEMENT_DOCUMENTS_DELETED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_EMAIL_BOUNCED = 'AGREEMENT_EMAIL_BOUNCED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_KBA_AUTHENTICATED = 'AGREEMENT_KBA_AUTHENTICATED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_OFFLINE_SYNC = 'AGREEMENT_OFFLINE_SYNC';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_USER_ACK_AGREEMENT_MODIFIED = 'AGREEMENT_USER_ACK_AGREEMENT_MODIFIED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_UPLOADED_BY_SENDER = 'AGREEMENT_UPLOADED_BY_SENDER';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_WEB_IDENTITY_AUTHENTICATED = 'AGREEMENT_WEB_IDENTITY_AUTHENTICATED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_ALL = 'AGREEMENT_ALL';
    const WEBHOOK_SUBSCRIPTION_EVENTS_MEGASIGN_CREATED = 'MEGASIGN_CREATED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_MEGASIGN_RECALLED = 'MEGASIGN_RECALLED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_MEGASIGN_SHARED = 'MEGASIGN_SHARED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_MEGASIGN_ALL = 'MEGASIGN_ALL';
    const WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_CREATED = 'WIDGET_CREATED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_MODIFIED = 'WIDGET_MODIFIED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_SHARED = 'WIDGET_SHARED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_ENABLED = 'WIDGET_ENABLED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_DISABLED = 'WIDGET_DISABLED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_AUTO_CANCELLED_CONVERSION_PROBLEM = 'WIDGET_AUTO_CANCELLED_CONVERSION_PROBLEM';
    const WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_ALL = 'WIDGET_ALL';
    const WEBHOOK_SUBSCRIPTION_EVENTS_LIBRARY_DOCUMENT_CREATED = 'LIBRARY_DOCUMENT_CREATED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_LIBRARY_DOCUMENT_AUTO_CANCELLED_CONVERSION_PROBLEM = 'LIBRARY_DOCUMENT_AUTO_CANCELLED_CONVERSION_PROBLEM';
    const WEBHOOK_SUBSCRIPTION_EVENTS_LIBRARY_DOCUMENT_MODIFIED = 'LIBRARY_DOCUMENT_MODIFIED';
    const WEBHOOK_SUBSCRIPTION_EVENTS_LIBRARY_DOCUMENT_ALL = 'LIBRARY_DOCUMENT_ALL';
    const SCOPE_ACCOUNT = 'ACCOUNT';
    const SCOPE_GROUP = 'GROUP';
    const SCOPE_USER = 'USER';
    const SCOPE_RESOURCE = 'RESOURCE';
    const STATE_ACTIVE = 'ACTIVE';
    const RESOURCE_TYPE_AGREEMENT = 'AGREEMENT';
    const RESOURCE_TYPE_WIDGET = 'WIDGET';
    const RESOURCE_TYPE_MEGASIGN = 'MEGASIGN';
    const RESOURCE_TYPE_LIBRARY_DOCUMENT = 'LIBRARY_DOCUMENT';
    const STATUS_ACTIVE = 'ACTIVE';
    const STATUS_INACTIVE = 'INACTIVE';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getWebhookSubscriptionEventsAllowableValues()
    {
        return [
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_CREATED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_ACTION_DELEGATED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_RECALLED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_REJECTED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_EXPIRED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_ACTION_COMPLETED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_WORKFLOW_COMPLETED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_EMAIL_VIEWED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_MODIFIED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_SHARED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_VAULTED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_ACTION_REQUESTED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_ACTION_REPLACED_SIGNER,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_AUTO_CANCELLED_CONVERSION_PROBLEM,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_DOCUMENTS_DELETED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_EMAIL_BOUNCED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_KBA_AUTHENTICATED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_OFFLINE_SYNC,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_USER_ACK_AGREEMENT_MODIFIED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_UPLOADED_BY_SENDER,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_WEB_IDENTITY_AUTHENTICATED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_AGREEMENT_ALL,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_MEGASIGN_CREATED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_MEGASIGN_RECALLED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_MEGASIGN_SHARED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_MEGASIGN_ALL,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_CREATED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_MODIFIED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_SHARED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_ENABLED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_DISABLED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_AUTO_CANCELLED_CONVERSION_PROBLEM,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_WIDGET_ALL,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_LIBRARY_DOCUMENT_CREATED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_LIBRARY_DOCUMENT_AUTO_CANCELLED_CONVERSION_PROBLEM,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_LIBRARY_DOCUMENT_MODIFIED,
            self::WEBHOOK_SUBSCRIPTION_EVENTS_LIBRARY_DOCUMENT_ALL,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getScopeAllowableValues()
    {
        return [
            self::SCOPE_ACCOUNT,
            self::SCOPE_GROUP,
            self::SCOPE_USER,
            self::SCOPE_RESOURCE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_ACTIVE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getResourceTypeAllowableValues()
    {
        return [
            self::RESOURCE_TYPE_AGREEMENT,
            self::RESOURCE_TYPE_WIDGET,
            self::RESOURCE_TYPE_MEGASIGN,
            self::RESOURCE_TYPE_LIBRARY_DOCUMENT,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_ACTIVE,
            self::STATUS_INACTIVE,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['resourceId'] = isset($data['resourceId']) ? $data['resourceId'] : null;
        $this->container['webhookUrlInfo'] = isset($data['webhookUrlInfo']) ? $data['webhookUrlInfo'] : null;
        $this->container['webhookConditionalParams'] = isset($data['webhookConditionalParams']) ? $data['webhookConditionalParams'] : null;
        $this->container['created'] = isset($data['created']) ? $data['created'] : null;
        $this->container['webhookSubscriptionEvents'] = isset($data['webhookSubscriptionEvents']) ? $data['webhookSubscriptionEvents'] : null;
        $this->container['applicationDisplayName'] = isset($data['applicationDisplayName']) ? $data['applicationDisplayName'] : null;
        $this->container['scope'] = isset($data['scope']) ? $data['scope'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['lastModified'] = isset($data['lastModified']) ? $data['lastModified'] : null;
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['applicationName'] = isset($data['applicationName']) ? $data['applicationName'] : null;
        $this->container['resourceType'] = isset($data['resourceType']) ? $data['resourceType'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getScopeAllowableValues();
        if (!is_null($this->container['scope']) && !in_array($this->container['scope'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'scope', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'state', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getResourceTypeAllowableValues();
        if (!is_null($this->container['resourceType']) && !in_array($this->container['resourceType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'resourceType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets resourceId
     *
     * @return string
     */
    public function getResourceId()
    {
        return $this->container['resourceId'];
    }

    /**
     * Sets resourceId
     *
     * @param string $resourceId Id of the resource type for which you want to create webhook. Provide agreementId if webhook needs to be created for an agreement. Similarly, widgetId if webhook needs to be created for a widget, megaSignId if webhook needs to be created for a megaSign and libraryDocumentId if webhook needs to be created for a library document. Need to specify only if scope is 'RESOURCE'. Can't be modified in PUT request
     *
     * @return $this
     */
    public function setResourceId($resourceId)
    {
        $this->container['resourceId'] = $resourceId;

        return $this;
    }

    /**
     * Gets webhookUrlInfo
     *
     * @return \Adobe\ESign\Model\WebhookUrlInfo
     */
    public function getWebhookUrlInfo()
    {
        return $this->container['webhookUrlInfo'];
    }

    /**
     * Sets webhookUrlInfo
     *
     * @param \Adobe\ESign\Model\WebhookUrlInfo $webhookUrlInfo Info of webhook url
     *
     * @return $this
     */
    public function setWebhookUrlInfo($webhookUrlInfo)
    {
        $this->container['webhookUrlInfo'] = $webhookUrlInfo;

        return $this;
    }

    /**
     * Gets webhookConditionalParams
     *
     * @return \Adobe\ESign\Model\WebhookConditionalParams
     */
    public function getWebhookConditionalParams()
    {
        return $this->container['webhookConditionalParams'];
    }

    /**
     * Sets webhookConditionalParams
     *
     * @param \Adobe\ESign\Model\WebhookConditionalParams $webhookConditionalParams Conditions which webhook creator can specify for the payload while creating or updating a webhook
     *
     * @return $this
     */
    public function setWebhookConditionalParams($webhookConditionalParams)
    {
        $this->container['webhookConditionalParams'] = $webhookConditionalParams;

        return $this;
    }

    /**
     * Gets created
     *
     * @return \DateTime
     */
    public function getCreated()
    {
        return $this->container['created'];
    }

    /**
     * Sets created
     *
     * @param \DateTime $created Timestamp when the webhook was created. Will only be returned in GET request. Can't be modified in PUT request
     *
     * @return $this
     */
    public function setCreated($created)
    {
        $this->container['created'] = $created;

        return $this;
    }

    /**
     * Gets webhookSubscriptionEvents
     *
     * @return string[]
     */
    public function getWebhookSubscriptionEvents()
    {
        return $this->container['webhookSubscriptionEvents'];
    }

    /**
     * Sets webhookSubscriptionEvents
     *
     * @param string[] $webhookSubscriptionEvents Determines events for which the webhook is triggered. The possible values are <br> AGREEMENT_CREATED : When an agreement is created <br>, AGREEMENT_ACTION_DELEGATED : When an agreement is delegated <br>, AGREEMENT_RECALLED : When an agreement is recalled <br>, AGREEMENT_REJECTED : When an agreement is rejected <br>, AGREEMENT_EXPIRED : When an agreement expires <br>, AGREEMENT_ACTION_COMPLETED : When an agreement action is completed <br>, AGREEMENT_WORKFLOW_COMPLETED : When an agreement workflow is completed <br>, AGREEMENT_EMAIL_VIEWED : When an agreement's email is viewed <br>, AGREEMENT_MODIFIED : When an agreement is modified <br>, AGREEMENT_SHARED : When an agreement is shared <br>, AGREEMENT_VAULTED : When an agreement is vaulted <br>, AGREEMENT_ACTION_REQUESTED : When an agreement action is requested <br>, AGREEMENT_ACTION_REPLACED_SIGNER : When signer is replaced for an agreement <br>, AGREEMENT_AUTO_CANCELLED_CONVERSION_PROBLEM : When an agreement is auto-cancelled due to conversion problem <br>, AGREEMENT_DOCUMENTS_DELETED : When an agreement documents are deleted <br>, AGREEMENT_EMAIL_BOUNCED : When an agreement email gets bounced <br>, AGREEMENT_KBA_AUTHENTICATED : When an agreement KBA is authenticated <br>, AGREEMENT_OFFLINE_SYNC : When an agreement is synced offline <br>, AGREEMENT_USER_ACK_AGREEMENT_MODIFIED : User Acknowledgement when an agreement is modified <br>, AGREEMENT_UPLOADED_BY_SENDER : When an agreement is uploaded by sender <br>, AGREEMENT_WEB_IDENTITY_AUTHENTICATED : When an agreement web identity is authenticated <br>, AGREEMENT_ALL : All the supported agreement events for Webhooks <br>, MEGASIGN_CREATED : When a megaSign is created <br>, MEGASIGN_RECALLED : When a megaSign is recalled <br>, MEGASIGN_SHARED : When a megaSign is shared <br>, MEGASIGN_ALL : All the supported megaSign events for Webhooks <br>, WIDGET_CREATED : When a widget is created <br>, WIDGET_MODIFIED : When a widget is modified <br>, WIDGET_SHARED : When a widget is shared <br>, WIDGET_ENABLED : When a widget is enabled <br>, WIDGET_DISABLED : When a widget is disabled <br>, WIDGET_AUTO_CANCELLED_CONVERSION_PROBLEM : When a widget is auto-cancelled due to conversion problem <br>, WIDGET_ALL : All the supported widget events for Webhooks <br>, LIBRARY_DOCUMENT_CREATED : When a library document  is created <br>, LIBRARY_DOCUMENT_AUTO_CANCELLED_CONVERSION_PROBLEM : When a library document is auto-cancelled due to conversion problem <br>, LIBRARY_DOCUMENT_MODIFIED : When a library document is modified <br>, LIBRARY_DOCUMENT_ALL : All the supported library document  events for Webhooks
     *
     * @return $this
     */
    public function setWebhookSubscriptionEvents($webhookSubscriptionEvents)
    {
        $allowedValues = $this->getWebhookSubscriptionEventsAllowableValues();
        if (!is_null($webhookSubscriptionEvents) && array_diff($webhookSubscriptionEvents, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'webhookSubscriptionEvents', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['webhookSubscriptionEvents'] = $webhookSubscriptionEvents;

        return $this;
    }

    /**
     * Gets applicationDisplayName
     *
     * @return string
     */
    public function getApplicationDisplayName()
    {
        return $this->container['applicationDisplayName'];
    }

    /**
     * Sets applicationDisplayName
     *
     * @param string $applicationDisplayName The display name of the application through which webhook is created
     *
     * @return $this
     */
    public function setApplicationDisplayName($applicationDisplayName)
    {
        $this->container['applicationDisplayName'] = $applicationDisplayName;

        return $this;
    }

    /**
     * Gets scope
     *
     * @return string
     */
    public function getScope()
    {
        return $this->container['scope'];
    }

    /**
     * Sets scope
     *
     * @param string $scope Scope of webhook. Can't be modified in PUT request. The possible values are ACCOUNT, GROUP, USER or RESOURCE
     *
     * @return $this
     */
    public function setScope($scope)
    {
        $allowedValues = $this->getScopeAllowableValues();
        if (!is_null($scope) && !in_array($scope, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'scope', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['scope'] = $scope;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name of the webhook
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id The unique identifier of the webhook. Will only be returned in GET request. Can't be modified in PUT request
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets lastModified
     *
     * @return \DateTime
     */
    public function getLastModified()
    {
        return $this->container['lastModified'];
    }

    /**
     * Sets lastModified
     *
     * @param \DateTime $lastModified Timestamp when the webhook was last updated. Will only be returned in GET request. Can't be modified in PUT request
     *
     * @return $this
     */
    public function setLastModified($lastModified)
    {
        $this->container['lastModified'] = $lastModified;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state The state in which the webhook should be created
     *
     * @return $this
     */
    public function setState($state)
    {
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($state) && !in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'state', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets applicationName
     *
     * @return string
     */
    public function getApplicationName()
    {
        return $this->container['applicationName'];
    }

    /**
     * Sets applicationName
     *
     * @param string $applicationName The name of the application through which webhook is created
     *
     * @return $this
     */
    public function setApplicationName($applicationName)
    {
        $this->container['applicationName'] = $applicationName;

        return $this;
    }

    /**
     * Gets resourceType
     *
     * @return string
     */
    public function getResourceType()
    {
        return $this->container['resourceType'];
    }

    /**
     * Sets resourceType
     *
     * @param string $resourceType The resource for which you want to create webhook. Need to specify only if scope is 'RESOURCE'. Can't be modified in PUT request. The possible values are AGREEMENT, WIDGET,  MEGASIGN AND LIBRARY_DOCUMENT
     *
     * @return $this
     */
    public function setResourceType($resourceType)
    {
        $allowedValues = $this->getResourceTypeAllowableValues();
        if (!is_null($resourceType) && !in_array($resourceType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'resourceType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['resourceType'] = $resourceType;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status Status of the webhook. Determines whether the webhook will be actually triggered. Default: ACTIVE, if ACTIVE, this webhook will receive event requests. If INACTIVE, this webhook will not receive event requests. Can't provide status in POST/PUT requests.
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


