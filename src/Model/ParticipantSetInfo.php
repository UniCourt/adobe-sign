<?php
/**
 * ParticipantSetInfo
 *
 * PHP version 5
 *
 * @category Class
 * @package  Adobe\ESign
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.4
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Adobe\ESign\Model;

use \ArrayAccess;
use \Adobe\ESign\ObjectSerializer;

/**
 * ParticipantSetInfo Class Doc Comment
 *
 * @category Class
 * @package  Adobe\ESign
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class ParticipantSetInfo implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'ParticipantSetInfo';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'role' => 'string',
        'visiblePages' => 'string[]',
        'name' => 'string',
        'label' => 'string',
        'privateMessage' => 'string',
        'memberInfos' => '\Adobe\ESign\Model\ParticipantSetMemberInfo[]',
        'order' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'role' => null,
        'visiblePages' => null,
        'name' => null,
        'label' => null,
        'privateMessage' => null,
        'memberInfos' => null,
        'order' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'role' => 'role',
        'visiblePages' => 'visiblePages',
        'name' => 'name',
        'label' => 'label',
        'privateMessage' => 'privateMessage',
        'memberInfos' => 'memberInfos',
        'order' => 'order'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'role' => 'setRole',
        'visiblePages' => 'setVisiblePages',
        'name' => 'setName',
        'label' => 'setLabel',
        'privateMessage' => 'setPrivateMessage',
        'memberInfos' => 'setMemberInfos',
        'order' => 'setOrder'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'role' => 'getRole',
        'visiblePages' => 'getVisiblePages',
        'name' => 'getName',
        'label' => 'getLabel',
        'privateMessage' => 'getPrivateMessage',
        'memberInfos' => 'getMemberInfos',
        'order' => 'getOrder'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const ROLE_SIGNER = 'SIGNER';
    const ROLE_APPROVER = 'APPROVER';
    const ROLE_ACCEPTOR = 'ACCEPTOR';
    const ROLE_CERTIFIED_RECIPIENT = 'CERTIFIED_RECIPIENT';
    const ROLE_FORM_FILLER = 'FORM_FILLER';
    const ROLE_DELEGATE_TO_SIGNER = 'DELEGATE_TO_SIGNER';
    const ROLE_DELEGATE_TO_APPROVER = 'DELEGATE_TO_APPROVER';
    const ROLE_DELEGATE_TO_ACCEPTOR = 'DELEGATE_TO_ACCEPTOR';
    const ROLE_DELEGATE_TO_CERTIFIED_RECIPIENT = 'DELEGATE_TO_CERTIFIED_RECIPIENT';
    const ROLE_DELEGATE_TO_FORM_FILLER = 'DELEGATE_TO_FORM_FILLER';
    const ROLE_SHARE = 'SHARE';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRoleAllowableValues()
    {
        return [
            self::ROLE_SIGNER,
            self::ROLE_APPROVER,
            self::ROLE_ACCEPTOR,
            self::ROLE_CERTIFIED_RECIPIENT,
            self::ROLE_FORM_FILLER,
            self::ROLE_DELEGATE_TO_SIGNER,
            self::ROLE_DELEGATE_TO_APPROVER,
            self::ROLE_DELEGATE_TO_ACCEPTOR,
            self::ROLE_DELEGATE_TO_CERTIFIED_RECIPIENT,
            self::ROLE_DELEGATE_TO_FORM_FILLER,
            self::ROLE_SHARE,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['role'] = isset($data['role']) ? $data['role'] : null;
        $this->container['visiblePages'] = isset($data['visiblePages']) ? $data['visiblePages'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['label'] = isset($data['label']) ? $data['label'] : null;
        $this->container['privateMessage'] = isset($data['privateMessage']) ? $data['privateMessage'] : null;
        $this->container['memberInfos'] = isset($data['memberInfos']) ? $data['memberInfos'] : null;
        $this->container['order'] = isset($data['order']) ? $data['order'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getRoleAllowableValues();
        if (!is_null($this->container['role']) && !in_array($this->container['role'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'role', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets role
     *
     * @return string
     */
    public function getRole()
    {
        return $this->container['role'];
    }

    /**
     * Sets role
     *
     * @param string $role Role assumed by all participants in the set (signer, approver etc.)
     *
     * @return $this
     */
    public function setRole($role)
    {
        $allowedValues = $this->getRoleAllowableValues();
        if (!is_null($role) && !in_array($role, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'role', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['role'] = $role;

        return $this;
    }

    /**
     * Gets visiblePages
     *
     * @return string[]
     */
    public function getVisiblePages()
    {
        return $this->container['visiblePages'];
    }

    /**
     * Sets visiblePages
     *
     * @param string[] $visiblePages When you enable limited document visibility (documentVisibilityEnabled), you can specify which file (fileInfo) should be made visible to which specific participant set.<br>Specify one or more label values of a fileInfos element.<br>Each signer participant sets must contain at least one required signature field in at least one visible file included in this API call; if not a page with a signature field is automatically appended for any missing participant sets. If there is a possibility that one or more participant sets do not have a required signature field in the files included in the API call, all signer participant sets should include a special index value of '0' to make this automatically appended signature page visible to the signer. Not doing so may result in an error. For all other roles, you may omit this value to exclude this page.
     *
     * @return $this
     */
    public function setVisiblePages($visiblePages)
    {
        $this->container['visiblePages'] = $visiblePages;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name Name of the participant set (it can be empty, but needs not to be unique in a single agreement). Maximum no of characters in participant set name is restricted to 255
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets label
     *
     * @return string
     */
    public function getLabel()
    {
        return $this->container['label'];
    }

    /**
     * Sets label
     *
     * @param string $label The unique label of a participant set.<br>For custom workflows, label specified in the participation set should map it to the participation step in the custom workflow.
     *
     * @return $this
     */
    public function setLabel($label)
    {
        $this->container['label'] = $label;

        return $this;
    }

    /**
     * Gets privateMessage
     *
     * @return string
     */
    public function getPrivateMessage()
    {
        return $this->container['privateMessage'];
    }

    /**
     * Sets privateMessage
     *
     * @param string $privateMessage Participant set's private message - all participants in the set will receive the same message
     *
     * @return $this
     */
    public function setPrivateMessage($privateMessage)
    {
        $this->container['privateMessage'] = $privateMessage;

        return $this;
    }

    /**
     * Gets memberInfos
     *
     * @return \Adobe\ESign\Model\ParticipantSetMemberInfo[]
     */
    public function getMemberInfos()
    {
        return $this->container['memberInfos'];
    }

    /**
     * Sets memberInfos
     *
     * @param \Adobe\ESign\Model\ParticipantSetMemberInfo[] $memberInfos Array of ParticipantInfo objects, containing participant-specific data (e.g. email). All participants in the array belong to the same set
     *
     * @return $this
     */
    public function setMemberInfos($memberInfos)
    {
        $this->container['memberInfos'] = $memberInfos;

        return $this;
    }

    /**
     * Gets order
     *
     * @return int
     */
    public function getOrder()
    {
        return $this->container['order'];
    }

    /**
     * Sets order
     *
     * @param int $order Index indicating position at which signing group needs to sign. Signing group to sign at first place is assigned a 1 index. Different signingOrder specified in input should form a valid consecutive increasing sequence of integers. Otherwise signingOrder will be considered invalid. No signingOrder should be specified for SHARE role
     *
     * @return $this
     */
    public function setOrder($order)
    {
        $this->container['order'] = $order;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


