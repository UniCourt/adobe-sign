<?php
/**
 * FormField
 *
 * PHP version 5
 *
 * @category Class
 * @package  Adobe\ESign
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.4
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Adobe\ESign\Model;

use \ArrayAccess;
use \Adobe\ESign\ObjectSerializer;

/**
 * FormField Class Doc Comment
 *
 * @category Class
 * @description A form field for an agreement.
 * @package  Adobe\ESign
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FormField implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'FormField';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'radioCheckType' => 'string',
        'borderColor' => 'string',
        'valueExpression' => 'string',
        'maskingText' => 'string',
        'defaultValue' => 'string',
        'masked' => 'bool',
        'minLength' => 'int',
        'origin' => 'string',
        'tooltip' => 'string',
        'hiddenOptions' => 'string[]',
        'required' => 'bool',
        'validationData' => 'string',
        'minValue' => 'double',
        'borderWidth' => 'double',
        'urlOverridable' => 'bool',
        'inputType' => 'string',
        'borderStyle' => 'string',
        'calculated' => 'bool',
        'contentType' => 'string',
        'validation' => 'string',
        'displayLabel' => 'string',
        'hyperlink' => '\Adobe\ESign\Model\FormFieldHyperlink',
        'backgroundColor' => 'string',
        'visible' => 'bool',
        'displayFormatType' => 'string',
        'maxValue' => 'double',
        'validationErrMsg' => 'string',
        'displayFormat' => 'string',
        'visibleOptions' => 'string[]',
        'readOnly' => 'bool',
        'fontName' => 'string',
        'conditionalAction' => '\Adobe\ESign\Model\FormFieldConditionalAction',
        'name' => 'string',
        'fontSize' => 'double',
        'locations' => '\Adobe\ESign\Model\FormFieldLocation[]',
        'assignee' => 'string',
        'alignment' => 'string',
        'fontColor' => 'string',
        'maxLength' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'radioCheckType' => null,
        'borderColor' => null,
        'valueExpression' => null,
        'maskingText' => null,
        'defaultValue' => null,
        'masked' => null,
        'minLength' => null,
        'origin' => null,
        'tooltip' => null,
        'hiddenOptions' => null,
        'required' => null,
        'validationData' => null,
        'minValue' => 'double',
        'borderWidth' => 'double',
        'urlOverridable' => null,
        'inputType' => null,
        'borderStyle' => null,
        'calculated' => null,
        'contentType' => null,
        'validation' => null,
        'displayLabel' => null,
        'hyperlink' => null,
        'backgroundColor' => null,
        'visible' => null,
        'displayFormatType' => null,
        'maxValue' => 'double',
        'validationErrMsg' => null,
        'displayFormat' => null,
        'visibleOptions' => null,
        'readOnly' => null,
        'fontName' => null,
        'conditionalAction' => null,
        'name' => null,
        'fontSize' => 'double',
        'locations' => null,
        'assignee' => null,
        'alignment' => null,
        'fontColor' => null,
        'maxLength' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'radioCheckType' => 'radioCheckType',
        'borderColor' => 'borderColor',
        'valueExpression' => 'valueExpression',
        'maskingText' => 'maskingText',
        'defaultValue' => 'defaultValue',
        'masked' => 'masked',
        'minLength' => 'minLength',
        'origin' => 'origin',
        'tooltip' => 'tooltip',
        'hiddenOptions' => 'hiddenOptions',
        'required' => 'required',
        'validationData' => 'validationData',
        'minValue' => 'minValue',
        'borderWidth' => 'borderWidth',
        'urlOverridable' => 'urlOverridable',
        'inputType' => 'inputType',
        'borderStyle' => 'borderStyle',
        'calculated' => 'calculated',
        'contentType' => 'contentType',
        'validation' => 'validation',
        'displayLabel' => 'displayLabel',
        'hyperlink' => 'hyperlink',
        'backgroundColor' => 'backgroundColor',
        'visible' => 'visible',
        'displayFormatType' => 'displayFormatType',
        'maxValue' => 'maxValue',
        'validationErrMsg' => 'validationErrMsg',
        'displayFormat' => 'displayFormat',
        'visibleOptions' => 'visibleOptions',
        'readOnly' => 'readOnly',
        'fontName' => 'fontName',
        'conditionalAction' => 'conditionalAction',
        'name' => 'name',
        'fontSize' => 'fontSize',
        'locations' => 'locations',
        'assignee' => 'assignee',
        'alignment' => 'alignment',
        'fontColor' => 'fontColor',
        'maxLength' => 'maxLength'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'radioCheckType' => 'setRadioCheckType',
        'borderColor' => 'setBorderColor',
        'valueExpression' => 'setValueExpression',
        'maskingText' => 'setMaskingText',
        'defaultValue' => 'setDefaultValue',
        'masked' => 'setMasked',
        'minLength' => 'setMinLength',
        'origin' => 'setOrigin',
        'tooltip' => 'setTooltip',
        'hiddenOptions' => 'setHiddenOptions',
        'required' => 'setRequired',
        'validationData' => 'setValidationData',
        'minValue' => 'setMinValue',
        'borderWidth' => 'setBorderWidth',
        'urlOverridable' => 'setUrlOverridable',
        'inputType' => 'setInputType',
        'borderStyle' => 'setBorderStyle',
        'calculated' => 'setCalculated',
        'contentType' => 'setContentType',
        'validation' => 'setValidation',
        'displayLabel' => 'setDisplayLabel',
        'hyperlink' => 'setHyperlink',
        'backgroundColor' => 'setBackgroundColor',
        'visible' => 'setVisible',
        'displayFormatType' => 'setDisplayFormatType',
        'maxValue' => 'setMaxValue',
        'validationErrMsg' => 'setValidationErrMsg',
        'displayFormat' => 'setDisplayFormat',
        'visibleOptions' => 'setVisibleOptions',
        'readOnly' => 'setReadOnly',
        'fontName' => 'setFontName',
        'conditionalAction' => 'setConditionalAction',
        'name' => 'setName',
        'fontSize' => 'setFontSize',
        'locations' => 'setLocations',
        'assignee' => 'setAssignee',
        'alignment' => 'setAlignment',
        'fontColor' => 'setFontColor',
        'maxLength' => 'setMaxLength'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'radioCheckType' => 'getRadioCheckType',
        'borderColor' => 'getBorderColor',
        'valueExpression' => 'getValueExpression',
        'maskingText' => 'getMaskingText',
        'defaultValue' => 'getDefaultValue',
        'masked' => 'getMasked',
        'minLength' => 'getMinLength',
        'origin' => 'getOrigin',
        'tooltip' => 'getTooltip',
        'hiddenOptions' => 'getHiddenOptions',
        'required' => 'getRequired',
        'validationData' => 'getValidationData',
        'minValue' => 'getMinValue',
        'borderWidth' => 'getBorderWidth',
        'urlOverridable' => 'getUrlOverridable',
        'inputType' => 'getInputType',
        'borderStyle' => 'getBorderStyle',
        'calculated' => 'getCalculated',
        'contentType' => 'getContentType',
        'validation' => 'getValidation',
        'displayLabel' => 'getDisplayLabel',
        'hyperlink' => 'getHyperlink',
        'backgroundColor' => 'getBackgroundColor',
        'visible' => 'getVisible',
        'displayFormatType' => 'getDisplayFormatType',
        'maxValue' => 'getMaxValue',
        'validationErrMsg' => 'getValidationErrMsg',
        'displayFormat' => 'getDisplayFormat',
        'visibleOptions' => 'getVisibleOptions',
        'readOnly' => 'getReadOnly',
        'fontName' => 'getFontName',
        'conditionalAction' => 'getConditionalAction',
        'name' => 'getName',
        'fontSize' => 'getFontSize',
        'locations' => 'getLocations',
        'assignee' => 'getAssignee',
        'alignment' => 'getAlignment',
        'fontColor' => 'getFontColor',
        'maxLength' => 'getMaxLength'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const RADIO_CHECK_TYPE_CIRCLE = 'CIRCLE';
    const RADIO_CHECK_TYPE_CHECK = 'CHECK';
    const RADIO_CHECK_TYPE_CROSS = 'CROSS';
    const RADIO_CHECK_TYPE_DIAMOND = 'DIAMOND';
    const RADIO_CHECK_TYPE_SQUARE = 'SQUARE';
    const RADIO_CHECK_TYPE_STAR = 'STAR';
    const ORIGIN_AUTHORED = 'AUTHORED';
    const ORIGIN_GENERATED = 'GENERATED';
    const ORIGIN_IMPORTED = 'IMPORTED';
    const INPUT_TYPE_TEXT_FIELD = 'TEXT_FIELD';
    const INPUT_TYPE_MULTILINE = 'MULTILINE';
    const INPUT_TYPE_PASSWORD = 'PASSWORD';
    const INPUT_TYPE_RADIO = 'RADIO';
    const INPUT_TYPE_CHECKBOX = 'CHECKBOX';
    const INPUT_TYPE_DROP_DOWN = 'DROP_DOWN';
    const INPUT_TYPE_LISTBOX = 'LISTBOX';
    const INPUT_TYPE_SIGNATURE = 'SIGNATURE';
    const INPUT_TYPE_PDF_SIGNATURE = 'PDF_SIGNATURE';
    const INPUT_TYPE_BUTTON = 'BUTTON';
    const INPUT_TYPE_BLOCK = 'BLOCK';
    const INPUT_TYPE_FILE_CHOOSER = 'FILE_CHOOSER';
    const INPUT_TYPE_COMB = 'COMB';
    const INPUT_TYPE_INLINE_IMAGE = 'INLINE_IMAGE';
    const INPUT_TYPE_UNSUPPORTED = 'UNSUPPORTED';
    const BORDER_STYLE_SOLID = 'SOLID';
    const BORDER_STYLE_DASHED = 'DASHED';
    const BORDER_STYLE_BEVELED = 'BEVELED';
    const BORDER_STYLE_INSET = 'INSET';
    const BORDER_STYLE_UNDERLINE = 'UNDERLINE';
    const CONTENT_TYPE_DATA = 'DATA';
    const CONTENT_TYPE_SIGNATURE_BLOCK = 'SIGNATURE_BLOCK';
    const CONTENT_TYPE_SIGNATURE = 'SIGNATURE';
    const CONTENT_TYPE_SIGNER_NAME = 'SIGNER_NAME';
    const CONTENT_TYPE_SIGNER_FIRST_NAME = 'SIGNER_FIRST_NAME';
    const CONTENT_TYPE_SIGNER_LAST_NAME = 'SIGNER_LAST_NAME';
    const CONTENT_TYPE_SIGNER_INITIALS = 'SIGNER_INITIALS';
    const CONTENT_TYPE_SIGNER_EMAIL = 'SIGNER_EMAIL';
    const CONTENT_TYPE_SIGNER_TITLE = 'SIGNER_TITLE';
    const CONTENT_TYPE_SIGNER_COMPANY = 'SIGNER_COMPANY';
    const CONTENT_TYPE_SIGNATURE_DATE = 'SIGNATURE_DATE';
    const CONTENT_TYPE_AGREEMENT_NAME = 'AGREEMENT_NAME';
    const CONTENT_TYPE_AGREEMENT_MESSAGE = 'AGREEMENT_MESSAGE';
    const CONTENT_TYPE_TRANSACTION_ID = 'TRANSACTION_ID';
    const CONTENT_TYPE_SIGNATURE_STAMP = 'SIGNATURE_STAMP';
    const CONTENT_TYPE_PAYMENT = 'PAYMENT';
    const CONTENT_TYPE_DIGITAL_SIGNATURE = 'DIGITAL_SIGNATURE';
    const VALIDATION_NONE = 'NONE';
    const VALIDATION_STRING = 'STRING';
    const VALIDATION_NUMBER = 'NUMBER';
    const VALIDATION_DATE = 'DATE';
    const VALIDATION_DATE_CUSTOM = 'DATE_CUSTOM';
    const VALIDATION_TIME = 'TIME';
    const VALIDATION_ZIP = 'ZIP';
    const VALIDATION_PHONE = 'PHONE';
    const VALIDATION_SOCIAL_SEC = 'SOCIAL_SEC';
    const VALIDATION_EMAIL = 'EMAIL';
    const VALIDATION_CURRENCY = 'CURRENCY';
    const VALIDATION_PERCENT = 'PERCENT';
    const VALIDATION_FORMULA = 'FORMULA';
    const VALIDATION_CUSTOM = 'CUSTOM';
    const VALIDATION_XFA_PICTURE = 'XFA_PICTURE';
    const DISPLAY_FORMAT_TYPE__DEFAULT = 'DEFAULT';
    const DISPLAY_FORMAT_TYPE_DATE = 'DATE';
    const DISPLAY_FORMAT_TYPE_NUMBER = 'NUMBER';
    const ALIGNMENT_LEFT = 'LEFT';
    const ALIGNMENT_RIGHT = 'RIGHT';
    const ALIGNMENT_CENTER = 'CENTER';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadioCheckTypeAllowableValues()
    {
        return [
            self::RADIO_CHECK_TYPE_CIRCLE,
            self::RADIO_CHECK_TYPE_CHECK,
            self::RADIO_CHECK_TYPE_CROSS,
            self::RADIO_CHECK_TYPE_DIAMOND,
            self::RADIO_CHECK_TYPE_SQUARE,
            self::RADIO_CHECK_TYPE_STAR,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getOriginAllowableValues()
    {
        return [
            self::ORIGIN_AUTHORED,
            self::ORIGIN_GENERATED,
            self::ORIGIN_IMPORTED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getInputTypeAllowableValues()
    {
        return [
            self::INPUT_TYPE_TEXT_FIELD,
            self::INPUT_TYPE_MULTILINE,
            self::INPUT_TYPE_PASSWORD,
            self::INPUT_TYPE_RADIO,
            self::INPUT_TYPE_CHECKBOX,
            self::INPUT_TYPE_DROP_DOWN,
            self::INPUT_TYPE_LISTBOX,
            self::INPUT_TYPE_SIGNATURE,
            self::INPUT_TYPE_PDF_SIGNATURE,
            self::INPUT_TYPE_BUTTON,
            self::INPUT_TYPE_BLOCK,
            self::INPUT_TYPE_FILE_CHOOSER,
            self::INPUT_TYPE_COMB,
            self::INPUT_TYPE_INLINE_IMAGE,
            self::INPUT_TYPE_UNSUPPORTED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getBorderStyleAllowableValues()
    {
        return [
            self::BORDER_STYLE_SOLID,
            self::BORDER_STYLE_DASHED,
            self::BORDER_STYLE_BEVELED,
            self::BORDER_STYLE_INSET,
            self::BORDER_STYLE_UNDERLINE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getContentTypeAllowableValues()
    {
        return [
            self::CONTENT_TYPE_DATA,
            self::CONTENT_TYPE_SIGNATURE_BLOCK,
            self::CONTENT_TYPE_SIGNATURE,
            self::CONTENT_TYPE_SIGNER_NAME,
            self::CONTENT_TYPE_SIGNER_FIRST_NAME,
            self::CONTENT_TYPE_SIGNER_LAST_NAME,
            self::CONTENT_TYPE_SIGNER_INITIALS,
            self::CONTENT_TYPE_SIGNER_EMAIL,
            self::CONTENT_TYPE_SIGNER_TITLE,
            self::CONTENT_TYPE_SIGNER_COMPANY,
            self::CONTENT_TYPE_SIGNATURE_DATE,
            self::CONTENT_TYPE_AGREEMENT_NAME,
            self::CONTENT_TYPE_AGREEMENT_MESSAGE,
            self::CONTENT_TYPE_TRANSACTION_ID,
            self::CONTENT_TYPE_SIGNATURE_STAMP,
            self::CONTENT_TYPE_PAYMENT,
            self::CONTENT_TYPE_DIGITAL_SIGNATURE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getValidationAllowableValues()
    {
        return [
            self::VALIDATION_NONE,
            self::VALIDATION_STRING,
            self::VALIDATION_NUMBER,
            self::VALIDATION_DATE,
            self::VALIDATION_DATE_CUSTOM,
            self::VALIDATION_TIME,
            self::VALIDATION_ZIP,
            self::VALIDATION_PHONE,
            self::VALIDATION_SOCIAL_SEC,
            self::VALIDATION_EMAIL,
            self::VALIDATION_CURRENCY,
            self::VALIDATION_PERCENT,
            self::VALIDATION_FORMULA,
            self::VALIDATION_CUSTOM,
            self::VALIDATION_XFA_PICTURE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDisplayFormatTypeAllowableValues()
    {
        return [
            self::DISPLAY_FORMAT_TYPE__DEFAULT,
            self::DISPLAY_FORMAT_TYPE_DATE,
            self::DISPLAY_FORMAT_TYPE_NUMBER,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAlignmentAllowableValues()
    {
        return [
            self::ALIGNMENT_LEFT,
            self::ALIGNMENT_RIGHT,
            self::ALIGNMENT_CENTER,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['radioCheckType'] = isset($data['radioCheckType']) ? $data['radioCheckType'] : null;
        $this->container['borderColor'] = isset($data['borderColor']) ? $data['borderColor'] : null;
        $this->container['valueExpression'] = isset($data['valueExpression']) ? $data['valueExpression'] : null;
        $this->container['maskingText'] = isset($data['maskingText']) ? $data['maskingText'] : null;
        $this->container['defaultValue'] = isset($data['defaultValue']) ? $data['defaultValue'] : null;
        $this->container['masked'] = isset($data['masked']) ? $data['masked'] : null;
        $this->container['minLength'] = isset($data['minLength']) ? $data['minLength'] : null;
        $this->container['origin'] = isset($data['origin']) ? $data['origin'] : null;
        $this->container['tooltip'] = isset($data['tooltip']) ? $data['tooltip'] : null;
        $this->container['hiddenOptions'] = isset($data['hiddenOptions']) ? $data['hiddenOptions'] : null;
        $this->container['required'] = isset($data['required']) ? $data['required'] : null;
        $this->container['validationData'] = isset($data['validationData']) ? $data['validationData'] : null;
        $this->container['minValue'] = isset($data['minValue']) ? $data['minValue'] : null;
        $this->container['borderWidth'] = isset($data['borderWidth']) ? $data['borderWidth'] : null;
        $this->container['urlOverridable'] = isset($data['urlOverridable']) ? $data['urlOverridable'] : null;
        $this->container['inputType'] = isset($data['inputType']) ? $data['inputType'] : null;
        $this->container['borderStyle'] = isset($data['borderStyle']) ? $data['borderStyle'] : null;
        $this->container['calculated'] = isset($data['calculated']) ? $data['calculated'] : null;
        $this->container['contentType'] = isset($data['contentType']) ? $data['contentType'] : null;
        $this->container['validation'] = isset($data['validation']) ? $data['validation'] : null;
        $this->container['displayLabel'] = isset($data['displayLabel']) ? $data['displayLabel'] : null;
        $this->container['hyperlink'] = isset($data['hyperlink']) ? $data['hyperlink'] : null;
        $this->container['backgroundColor'] = isset($data['backgroundColor']) ? $data['backgroundColor'] : null;
        $this->container['visible'] = isset($data['visible']) ? $data['visible'] : null;
        $this->container['displayFormatType'] = isset($data['displayFormatType']) ? $data['displayFormatType'] : null;
        $this->container['maxValue'] = isset($data['maxValue']) ? $data['maxValue'] : null;
        $this->container['validationErrMsg'] = isset($data['validationErrMsg']) ? $data['validationErrMsg'] : null;
        $this->container['displayFormat'] = isset($data['displayFormat']) ? $data['displayFormat'] : null;
        $this->container['visibleOptions'] = isset($data['visibleOptions']) ? $data['visibleOptions'] : null;
        $this->container['readOnly'] = isset($data['readOnly']) ? $data['readOnly'] : null;
        $this->container['fontName'] = isset($data['fontName']) ? $data['fontName'] : null;
        $this->container['conditionalAction'] = isset($data['conditionalAction']) ? $data['conditionalAction'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['fontSize'] = isset($data['fontSize']) ? $data['fontSize'] : null;
        $this->container['locations'] = isset($data['locations']) ? $data['locations'] : null;
        $this->container['assignee'] = isset($data['assignee']) ? $data['assignee'] : null;
        $this->container['alignment'] = isset($data['alignment']) ? $data['alignment'] : null;
        $this->container['fontColor'] = isset($data['fontColor']) ? $data['fontColor'] : null;
        $this->container['maxLength'] = isset($data['maxLength']) ? $data['maxLength'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getRadioCheckTypeAllowableValues();
        if (!is_null($this->container['radioCheckType']) && !in_array($this->container['radioCheckType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'radioCheckType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getOriginAllowableValues();
        if (!is_null($this->container['origin']) && !in_array($this->container['origin'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'origin', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getInputTypeAllowableValues();
        if (!is_null($this->container['inputType']) && !in_array($this->container['inputType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'inputType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getBorderStyleAllowableValues();
        if (!is_null($this->container['borderStyle']) && !in_array($this->container['borderStyle'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'borderStyle', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getContentTypeAllowableValues();
        if (!is_null($this->container['contentType']) && !in_array($this->container['contentType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'contentType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getValidationAllowableValues();
        if (!is_null($this->container['validation']) && !in_array($this->container['validation'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'validation', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getDisplayFormatTypeAllowableValues();
        if (!is_null($this->container['displayFormatType']) && !in_array($this->container['displayFormatType'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'displayFormatType', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAlignmentAllowableValues();
        if (!is_null($this->container['alignment']) && !in_array($this->container['alignment'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'alignment', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets radioCheckType
     *
     * @return string
     */
    public function getRadioCheckType()
    {
        return $this->container['radioCheckType'];
    }

    /**
     * Sets radioCheckType
     *
     * @param string $radioCheckType The type of radio button (if field is radio button, identified by inputType).
     *
     * @return $this
     */
    public function setRadioCheckType($radioCheckType)
    {
        $allowedValues = $this->getRadioCheckTypeAllowableValues();
        if (!is_null($radioCheckType) && !in_array($radioCheckType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'radioCheckType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radioCheckType'] = $radioCheckType;

        return $this;
    }

    /**
     * Gets borderColor
     *
     * @return string
     */
    public function getBorderColor()
    {
        return $this->container['borderColor'];
    }

    /**
     * Sets borderColor
     *
     * @param string $borderColor Color of the border of the field in RGB or HEX format
     *
     * @return $this
     */
    public function setBorderColor($borderColor)
    {
        $this->container['borderColor'] = $borderColor;

        return $this;
    }

    /**
     * Gets valueExpression
     *
     * @return string
     */
    public function getValueExpression()
    {
        return $this->container['valueExpression'];
    }

    /**
     * Sets valueExpression
     *
     * @param string $valueExpression Expression to calculate value of the form field
     *
     * @return $this
     */
    public function setValueExpression($valueExpression)
    {
        $this->container['valueExpression'] = $valueExpression;

        return $this;
    }

    /**
     * Gets maskingText
     *
     * @return string
     */
    public function getMaskingText()
    {
        return $this->container['maskingText'];
    }

    /**
     * Sets maskingText
     *
     * @param string $maskingText Text to mask the masked form field
     *
     * @return $this
     */
    public function setMaskingText($maskingText)
    {
        $this->container['maskingText'] = $maskingText;

        return $this;
    }

    /**
     * Gets defaultValue
     *
     * @return string
     */
    public function getDefaultValue()
    {
        return $this->container['defaultValue'];
    }

    /**
     * Sets defaultValue
     *
     * @param string $defaultValue Default value of the form field
     *
     * @return $this
     */
    public function setDefaultValue($defaultValue)
    {
        $this->container['defaultValue'] = $defaultValue;

        return $this;
    }

    /**
     * Gets masked
     *
     * @return bool
     */
    public function getMasked()
    {
        return $this->container['masked'];
    }

    /**
     * Sets masked
     *
     * @param bool $masked true if the input entered by the signer has to be masked (like password), false if it shouldn't be
     *
     * @return $this
     */
    public function setMasked($masked)
    {
        $this->container['masked'] = $masked;

        return $this;
    }

    /**
     * Gets minLength
     *
     * @return int
     */
    public function getMinLength()
    {
        return $this->container['minLength'];
    }

    /**
     * Sets minLength
     *
     * @param int $minLength Minimum length of the input text field in terms of no. of characters
     *
     * @return $this
     */
    public function setMinLength($minLength)
    {
        $this->container['minLength'] = $minLength;

        return $this;
    }

    /**
     * Gets origin
     *
     * @return string
     */
    public function getOrigin()
    {
        return $this->container['origin'];
    }

    /**
     * Sets origin
     *
     * @param string $origin Origin of Form Field
     *
     * @return $this
     */
    public function setOrigin($origin)
    {
        $allowedValues = $this->getOriginAllowableValues();
        if (!is_null($origin) && !in_array($origin, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'origin', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['origin'] = $origin;

        return $this;
    }

    /**
     * Gets tooltip
     *
     * @return string
     */
    public function getTooltip()
    {
        return $this->container['tooltip'];
    }

    /**
     * Sets tooltip
     *
     * @param string $tooltip Text that appears while hovering over the field
     *
     * @return $this
     */
    public function setTooltip($tooltip)
    {
        $this->container['tooltip'] = $tooltip;

        return $this;
    }

    /**
     * Gets hiddenOptions
     *
     * @return string[]
     */
    public function getHiddenOptions()
    {
        return $this->container['hiddenOptions'];
    }

    /**
     * Sets hiddenOptions
     *
     * @param string[] $hiddenOptions Text values which are hidden in a drop down form field
     *
     * @return $this
     */
    public function setHiddenOptions($hiddenOptions)
    {
        $this->container['hiddenOptions'] = $hiddenOptions;

        return $this;
    }

    /**
     * Gets required
     *
     * @return bool
     */
    public function getRequired()
    {
        return $this->container['required'];
    }

    /**
     * Sets required
     *
     * @param bool $required true if it is a mandatory field to be filled by the signer, else false
     *
     * @return $this
     */
    public function setRequired($required)
    {
        $this->container['required'] = $required;

        return $this;
    }

    /**
     * Gets validationData
     *
     * @return string
     */
    public function getValidationData()
    {
        return $this->container['validationData'];
    }

    /**
     * Sets validationData
     *
     * @param string $validationData Further data for validating input with regards to the field's specified format. The contents and interpretation of formatData depends on the value of validation.
     *
     * @return $this
     */
    public function setValidationData($validationData)
    {
        $this->container['validationData'] = $validationData;

        return $this;
    }

    /**
     * Gets minValue
     *
     * @return double
     */
    public function getMinValue()
    {
        return $this->container['minValue'];
    }

    /**
     * Sets minValue
     *
     * @param double $minValue Lower bound of the number that can be entered by the signer
     *
     * @return $this
     */
    public function setMinValue($minValue)
    {
        $this->container['minValue'] = $minValue;

        return $this;
    }

    /**
     * Gets borderWidth
     *
     * @return double
     */
    public function getBorderWidth()
    {
        return $this->container['borderWidth'];
    }

    /**
     * Sets borderWidth
     *
     * @param double $borderWidth Width of the border of the field in pixels
     *
     * @return $this
     */
    public function setBorderWidth($borderWidth)
    {
        $this->container['borderWidth'] = $borderWidth;

        return $this;
    }

    /**
     * Gets urlOverridable
     *
     * @return bool
     */
    public function getUrlOverridable()
    {
        return $this->container['urlOverridable'];
    }

    /**
     * Sets urlOverridable
     *
     * @param bool $urlOverridable For widget text fields only - true if the default value may come from the URL, else false
     *
     * @return $this
     */
    public function setUrlOverridable($urlOverridable)
    {
        $this->container['urlOverridable'] = $urlOverridable;

        return $this;
    }

    /**
     * Gets inputType
     *
     * @return string
     */
    public function getInputType()
    {
        return $this->container['inputType'];
    }

    /**
     * Sets inputType
     *
     * @param string $inputType Input type of the form field
     *
     * @return $this
     */
    public function setInputType($inputType)
    {
        $allowedValues = $this->getInputTypeAllowableValues();
        if (!is_null($inputType) && !in_array($inputType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'inputType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['inputType'] = $inputType;

        return $this;
    }

    /**
     * Gets borderStyle
     *
     * @return string
     */
    public function getBorderStyle()
    {
        return $this->container['borderStyle'];
    }

    /**
     * Sets borderStyle
     *
     * @param string $borderStyle Style of the border of the field.
     *
     * @return $this
     */
    public function setBorderStyle($borderStyle)
    {
        $allowedValues = $this->getBorderStyleAllowableValues();
        if (!is_null($borderStyle) && !in_array($borderStyle, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'borderStyle', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['borderStyle'] = $borderStyle;

        return $this;
    }

    /**
     * Gets calculated
     *
     * @return bool
     */
    public function getCalculated()
    {
        return $this->container['calculated'];
    }

    /**
     * Sets calculated
     *
     * @param bool $calculated true if this field's value is calculated from an expression, else false
     *
     * @return $this
     */
    public function setCalculated($calculated)
    {
        $this->container['calculated'] = $calculated;

        return $this;
    }

    /**
     * Gets contentType
     *
     * @return string
     */
    public function getContentType()
    {
        return $this->container['contentType'];
    }

    /**
     * Sets contentType
     *
     * @param string $contentType Content Type of the form field.
     *
     * @return $this
     */
    public function setContentType($contentType)
    {
        $allowedValues = $this->getContentTypeAllowableValues();
        if (!is_null($contentType) && !in_array($contentType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'contentType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['contentType'] = $contentType;

        return $this;
    }

    /**
     * Gets validation
     *
     * @return string
     */
    public function getValidation()
    {
        return $this->container['validation'];
    }

    /**
     * Sets validation
     *
     * @param string $validation Rule for validating the field value.
     *
     * @return $this
     */
    public function setValidation($validation)
    {
        $allowedValues = $this->getValidationAllowableValues();
        if (!is_null($validation) && !in_array($validation, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'validation', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['validation'] = $validation;

        return $this;
    }

    /**
     * Gets displayLabel
     *
     * @return string
     */
    public function getDisplayLabel()
    {
        return $this->container['displayLabel'];
    }

    /**
     * Sets displayLabel
     *
     * @param string $displayLabel Display label attached to the field
     *
     * @return $this
     */
    public function setDisplayLabel($displayLabel)
    {
        $this->container['displayLabel'] = $displayLabel;

        return $this;
    }

    /**
     * Gets hyperlink
     *
     * @return \Adobe\ESign\Model\FormFieldHyperlink
     */
    public function getHyperlink()
    {
        return $this->container['hyperlink'];
    }

    /**
     * Sets hyperlink
     *
     * @param \Adobe\ESign\Model\FormFieldHyperlink $hyperlink Hyperlink-specific data (e.g. as url, link type)
     *
     * @return $this
     */
    public function setHyperlink($hyperlink)
    {
        $this->container['hyperlink'] = $hyperlink;

        return $this;
    }

    /**
     * Gets backgroundColor
     *
     * @return string
     */
    public function getBackgroundColor()
    {
        return $this->container['backgroundColor'];
    }

    /**
     * Sets backgroundColor
     *
     * @param string $backgroundColor Background color of the form field in RGB or HEX format
     *
     * @return $this
     */
    public function setBackgroundColor($backgroundColor)
    {
        $this->container['backgroundColor'] = $backgroundColor;

        return $this;
    }

    /**
     * Gets visible
     *
     * @return bool
     */
    public function getVisible()
    {
        return $this->container['visible'];
    }

    /**
     * Sets visible
     *
     * @param bool $visible If set to false, then the form field is hidden.  Otherwise, it is visible.
     *
     * @return $this
     */
    public function setVisible($visible)
    {
        $this->container['visible'] = $visible;

        return $this;
    }

    /**
     * Gets displayFormatType
     *
     * @return string
     */
    public function getDisplayFormatType()
    {
        return $this->container['displayFormatType'];
    }

    /**
     * Sets displayFormatType
     *
     * @param string $displayFormatType Format type of the text field.
     *
     * @return $this
     */
    public function setDisplayFormatType($displayFormatType)
    {
        $allowedValues = $this->getDisplayFormatTypeAllowableValues();
        if (!is_null($displayFormatType) && !in_array($displayFormatType, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'displayFormatType', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['displayFormatType'] = $displayFormatType;

        return $this;
    }

    /**
     * Gets maxValue
     *
     * @return double
     */
    public function getMaxValue()
    {
        return $this->container['maxValue'];
    }

    /**
     * Sets maxValue
     *
     * @param double $maxValue Upper bound of the number that can be entered by the signer
     *
     * @return $this
     */
    public function setMaxValue($maxValue)
    {
        $this->container['maxValue'] = $maxValue;

        return $this;
    }

    /**
     * Gets validationErrMsg
     *
     * @return string
     */
    public function getValidationErrMsg()
    {
        return $this->container['validationErrMsg'];
    }

    /**
     * Sets validationErrMsg
     *
     * @param string $validationErrMsg Error message to be shown to the signer if filled value doesn't match the validations of the form field
     *
     * @return $this
     */
    public function setValidationErrMsg($validationErrMsg)
    {
        $this->container['validationErrMsg'] = $validationErrMsg;

        return $this;
    }

    /**
     * Gets displayFormat
     *
     * @return string
     */
    public function getDisplayFormat()
    {
        return $this->container['displayFormat'];
    }

    /**
     * Sets displayFormat
     *
     * @param string $displayFormat Format of the value of the field to be displayed based on the displayFormatType property.
     *
     * @return $this
     */
    public function setDisplayFormat($displayFormat)
    {
        $this->container['displayFormat'] = $displayFormat;

        return $this;
    }

    /**
     * Gets visibleOptions
     *
     * @return string[]
     */
    public function getVisibleOptions()
    {
        return $this->container['visibleOptions'];
    }

    /**
     * Sets visibleOptions
     *
     * @param string[] $visibleOptions Text values which are visible in a drop down form field
     *
     * @return $this
     */
    public function setVisibleOptions($visibleOptions)
    {
        $this->container['visibleOptions'] = $visibleOptions;

        return $this;
    }

    /**
     * Gets readOnly
     *
     * @return bool
     */
    public function getReadOnly()
    {
        return $this->container['readOnly'];
    }

    /**
     * Sets readOnly
     *
     * @param bool $readOnly true if it is a read-only field, else false
     *
     * @return $this
     */
    public function setReadOnly($readOnly)
    {
        $this->container['readOnly'] = $readOnly;

        return $this;
    }

    /**
     * Gets fontName
     *
     * @return string
     */
    public function getFontName()
    {
        return $this->container['fontName'];
    }

    /**
     * Sets fontName
     *
     * @param string $fontName Font name of the form field
     *
     * @return $this
     */
    public function setFontName($fontName)
    {
        $this->container['fontName'] = $fontName;

        return $this;
    }

    /**
     * Gets conditionalAction
     *
     * @return \Adobe\ESign\Model\FormFieldConditionalAction
     */
    public function getConditionalAction()
    {
        return $this->container['conditionalAction'];
    }

    /**
     * Sets conditionalAction
     *
     * @param \Adobe\ESign\Model\FormFieldConditionalAction $conditionalAction A predicate (or set of predicates) that determines whether this field is visible and enabled.
     *
     * @return $this
     */
    public function setConditionalAction($conditionalAction)
    {
        $this->container['conditionalAction'] = $conditionalAction;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name of the form field
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets fontSize
     *
     * @return double
     */
    public function getFontSize()
    {
        return $this->container['fontSize'];
    }

    /**
     * Sets fontSize
     *
     * @param double $fontSize Font size of the form field in points
     *
     * @return $this
     */
    public function setFontSize($fontSize)
    {
        $this->container['fontSize'] = $fontSize;

        return $this;
    }

    /**
     * Gets locations
     *
     * @return \Adobe\ESign\Model\FormFieldLocation[]
     */
    public function getLocations()
    {
        return $this->container['locations'];
    }

    /**
     * Sets locations
     *
     * @param \Adobe\ESign\Model\FormFieldLocation[] $locations All locations in a document where the form field is placed
     *
     * @return $this
     */
    public function setLocations($locations)
    {
        $this->container['locations'] = $locations;

        return $this;
    }

    /**
     * Gets assignee
     *
     * @return string
     */
    public function getAssignee()
    {
        return $this->container['assignee'];
    }

    /**
     * Sets assignee
     *
     * @param string $assignee Who the field is assigned to.  Either a participant set id, null, NOBODY or PREFILL.
     *
     * @return $this
     */
    public function setAssignee($assignee)
    {
        $this->container['assignee'] = $assignee;

        return $this;
    }

    /**
     * Gets alignment
     *
     * @return string
     */
    public function getAlignment()
    {
        return $this->container['alignment'];
    }

    /**
     * Sets alignment
     *
     * @param string $alignment Alignment of the text.
     *
     * @return $this
     */
    public function setAlignment($alignment)
    {
        $allowedValues = $this->getAlignmentAllowableValues();
        if (!is_null($alignment) && !in_array($alignment, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'alignment', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['alignment'] = $alignment;

        return $this;
    }

    /**
     * Gets fontColor
     *
     * @return string
     */
    public function getFontColor()
    {
        return $this->container['fontColor'];
    }

    /**
     * Sets fontColor
     *
     * @param string $fontColor Font color of the form field in RGB or HEX format
     *
     * @return $this
     */
    public function setFontColor($fontColor)
    {
        $this->container['fontColor'] = $fontColor;

        return $this;
    }

    /**
     * Gets maxLength
     *
     * @return int
     */
    public function getMaxLength()
    {
        return $this->container['maxLength'];
    }

    /**
     * Sets maxLength
     *
     * @param int $maxLength Maximum length of the input text field in terms of no. of characters
     *
     * @return $this
     */
    public function setMaxLength($maxLength)
    {
        $this->container['maxLength'] = $maxLength;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


