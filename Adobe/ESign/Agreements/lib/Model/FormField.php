<?php
/**
 * FormField
 *
 * PHP version 5
 *
 * @category Class
 * @package  Adobe\ESign\Agreements
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.0
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Adobe\ESign\Agreements\Model;

use \ArrayAccess;
use \Adobe\ESign\Agreements\ObjectSerializer;

/**
 * FormField Class Doc Comment
 *
 * @category Class
 * @description A form field for an agreement.
 * @package  Adobe\ESign\Agreements
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class FormField implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'FormField';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'radio_check_type' => 'string',
        'border_color' => 'string',
        'value_expression' => 'string',
        'masking_text' => 'string',
        'default_value' => 'string',
        'masked' => 'bool',
        'min_length' => 'int',
        'origin' => 'string',
        'tooltip' => 'string',
        'hidden_options' => 'string[]',
        'required' => 'bool',
        'validation_data' => 'string',
        'min_value' => 'double',
        'border_width' => 'double',
        'url_overridable' => 'bool',
        'input_type' => 'string',
        'border_style' => 'string',
        'calculated' => 'bool',
        'content_type' => 'string',
        'validation' => 'string',
        'display_label' => 'string',
        'hyperlink' => '\Adobe\ESign\Agreements\Model\FormFieldHyperlink',
        'background_color' => 'string',
        'visible' => 'bool',
        'display_format_type' => 'string',
        'max_value' => 'double',
        'validation_err_msg' => 'string',
        'display_format' => 'string',
        'visible_options' => 'string[]',
        'read_only' => 'bool',
        'font_name' => 'string',
        'conditional_action' => '\Adobe\ESign\Agreements\Model\FormFieldConditionalAction',
        'name' => 'string',
        'font_size' => 'double',
        'locations' => '\Adobe\ESign\Agreements\Model\FormFieldLocation[]',
        'assignee' => 'string',
        'alignment' => 'string',
        'font_color' => 'string',
        'max_length' => 'int'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'radio_check_type' => null,
        'border_color' => null,
        'value_expression' => null,
        'masking_text' => null,
        'default_value' => null,
        'masked' => null,
        'min_length' => null,
        'origin' => null,
        'tooltip' => null,
        'hidden_options' => null,
        'required' => null,
        'validation_data' => null,
        'min_value' => 'double',
        'border_width' => 'double',
        'url_overridable' => null,
        'input_type' => null,
        'border_style' => null,
        'calculated' => null,
        'content_type' => null,
        'validation' => null,
        'display_label' => null,
        'hyperlink' => null,
        'background_color' => null,
        'visible' => null,
        'display_format_type' => null,
        'max_value' => 'double',
        'validation_err_msg' => null,
        'display_format' => null,
        'visible_options' => null,
        'read_only' => null,
        'font_name' => null,
        'conditional_action' => null,
        'name' => null,
        'font_size' => 'double',
        'locations' => null,
        'assignee' => null,
        'alignment' => null,
        'font_color' => null,
        'max_length' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'radio_check_type' => 'radioCheckType',
        'border_color' => 'borderColor',
        'value_expression' => 'valueExpression',
        'masking_text' => 'maskingText',
        'default_value' => 'defaultValue',
        'masked' => 'masked',
        'min_length' => 'minLength',
        'origin' => 'origin',
        'tooltip' => 'tooltip',
        'hidden_options' => 'hiddenOptions',
        'required' => 'required',
        'validation_data' => 'validationData',
        'min_value' => 'minValue',
        'border_width' => 'borderWidth',
        'url_overridable' => 'urlOverridable',
        'input_type' => 'inputType',
        'border_style' => 'borderStyle',
        'calculated' => 'calculated',
        'content_type' => 'contentType',
        'validation' => 'validation',
        'display_label' => 'displayLabel',
        'hyperlink' => 'hyperlink',
        'background_color' => 'backgroundColor',
        'visible' => 'visible',
        'display_format_type' => 'displayFormatType',
        'max_value' => 'maxValue',
        'validation_err_msg' => 'validationErrMsg',
        'display_format' => 'displayFormat',
        'visible_options' => 'visibleOptions',
        'read_only' => 'readOnly',
        'font_name' => 'fontName',
        'conditional_action' => 'conditionalAction',
        'name' => 'name',
        'font_size' => 'fontSize',
        'locations' => 'locations',
        'assignee' => 'assignee',
        'alignment' => 'alignment',
        'font_color' => 'fontColor',
        'max_length' => 'maxLength'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'radio_check_type' => 'setRadioCheckType',
        'border_color' => 'setBorderColor',
        'value_expression' => 'setValueExpression',
        'masking_text' => 'setMaskingText',
        'default_value' => 'setDefaultValue',
        'masked' => 'setMasked',
        'min_length' => 'setMinLength',
        'origin' => 'setOrigin',
        'tooltip' => 'setTooltip',
        'hidden_options' => 'setHiddenOptions',
        'required' => 'setRequired',
        'validation_data' => 'setValidationData',
        'min_value' => 'setMinValue',
        'border_width' => 'setBorderWidth',
        'url_overridable' => 'setUrlOverridable',
        'input_type' => 'setInputType',
        'border_style' => 'setBorderStyle',
        'calculated' => 'setCalculated',
        'content_type' => 'setContentType',
        'validation' => 'setValidation',
        'display_label' => 'setDisplayLabel',
        'hyperlink' => 'setHyperlink',
        'background_color' => 'setBackgroundColor',
        'visible' => 'setVisible',
        'display_format_type' => 'setDisplayFormatType',
        'max_value' => 'setMaxValue',
        'validation_err_msg' => 'setValidationErrMsg',
        'display_format' => 'setDisplayFormat',
        'visible_options' => 'setVisibleOptions',
        'read_only' => 'setReadOnly',
        'font_name' => 'setFontName',
        'conditional_action' => 'setConditionalAction',
        'name' => 'setName',
        'font_size' => 'setFontSize',
        'locations' => 'setLocations',
        'assignee' => 'setAssignee',
        'alignment' => 'setAlignment',
        'font_color' => 'setFontColor',
        'max_length' => 'setMaxLength'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'radio_check_type' => 'getRadioCheckType',
        'border_color' => 'getBorderColor',
        'value_expression' => 'getValueExpression',
        'masking_text' => 'getMaskingText',
        'default_value' => 'getDefaultValue',
        'masked' => 'getMasked',
        'min_length' => 'getMinLength',
        'origin' => 'getOrigin',
        'tooltip' => 'getTooltip',
        'hidden_options' => 'getHiddenOptions',
        'required' => 'getRequired',
        'validation_data' => 'getValidationData',
        'min_value' => 'getMinValue',
        'border_width' => 'getBorderWidth',
        'url_overridable' => 'getUrlOverridable',
        'input_type' => 'getInputType',
        'border_style' => 'getBorderStyle',
        'calculated' => 'getCalculated',
        'content_type' => 'getContentType',
        'validation' => 'getValidation',
        'display_label' => 'getDisplayLabel',
        'hyperlink' => 'getHyperlink',
        'background_color' => 'getBackgroundColor',
        'visible' => 'getVisible',
        'display_format_type' => 'getDisplayFormatType',
        'max_value' => 'getMaxValue',
        'validation_err_msg' => 'getValidationErrMsg',
        'display_format' => 'getDisplayFormat',
        'visible_options' => 'getVisibleOptions',
        'read_only' => 'getReadOnly',
        'font_name' => 'getFontName',
        'conditional_action' => 'getConditionalAction',
        'name' => 'getName',
        'font_size' => 'getFontSize',
        'locations' => 'getLocations',
        'assignee' => 'getAssignee',
        'alignment' => 'getAlignment',
        'font_color' => 'getFontColor',
        'max_length' => 'getMaxLength'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const RADIO_CHECK_TYPE_CIRCLE = 'CIRCLE';
    const RADIO_CHECK_TYPE_CHECK = 'CHECK';
    const RADIO_CHECK_TYPE_CROSS = 'CROSS';
    const RADIO_CHECK_TYPE_DIAMOND = 'DIAMOND';
    const RADIO_CHECK_TYPE_SQUARE = 'SQUARE';
    const RADIO_CHECK_TYPE_STAR = 'STAR';
    const ORIGIN_AUTHORED = 'AUTHORED';
    const ORIGIN_GENERATED = 'GENERATED';
    const ORIGIN_IMPORTED = 'IMPORTED';
    const INPUT_TYPE_TEXT_FIELD = 'TEXT_FIELD';
    const INPUT_TYPE_MULTILINE = 'MULTILINE';
    const INPUT_TYPE_PASSWORD = 'PASSWORD';
    const INPUT_TYPE_RADIO = 'RADIO';
    const INPUT_TYPE_CHECKBOX = 'CHECKBOX';
    const INPUT_TYPE_DROP_DOWN = 'DROP_DOWN';
    const INPUT_TYPE_LISTBOX = 'LISTBOX';
    const INPUT_TYPE_SIGNATURE = 'SIGNATURE';
    const INPUT_TYPE_PDF_SIGNATURE = 'PDF_SIGNATURE';
    const INPUT_TYPE_BUTTON = 'BUTTON';
    const INPUT_TYPE_BLOCK = 'BLOCK';
    const INPUT_TYPE_FILE_CHOOSER = 'FILE_CHOOSER';
    const INPUT_TYPE_COMB = 'COMB';
    const INPUT_TYPE_INLINE_IMAGE = 'INLINE_IMAGE';
    const INPUT_TYPE_UNSUPPORTED = 'UNSUPPORTED';
    const BORDER_STYLE_SOLID = 'SOLID';
    const BORDER_STYLE_DASHED = 'DASHED';
    const BORDER_STYLE_BEVELED = 'BEVELED';
    const BORDER_STYLE_INSET = 'INSET';
    const BORDER_STYLE_UNDERLINE = 'UNDERLINE';
    const CONTENT_TYPE_DATA = 'DATA';
    const CONTENT_TYPE_SIGNATURE_BLOCK = 'SIGNATURE_BLOCK';
    const CONTENT_TYPE_SIGNATURE = 'SIGNATURE';
    const CONTENT_TYPE_SIGNER_NAME = 'SIGNER_NAME';
    const CONTENT_TYPE_SIGNER_FIRST_NAME = 'SIGNER_FIRST_NAME';
    const CONTENT_TYPE_SIGNER_LAST_NAME = 'SIGNER_LAST_NAME';
    const CONTENT_TYPE_SIGNER_INITIALS = 'SIGNER_INITIALS';
    const CONTENT_TYPE_SIGNER_EMAIL = 'SIGNER_EMAIL';
    const CONTENT_TYPE_SIGNER_TITLE = 'SIGNER_TITLE';
    const CONTENT_TYPE_SIGNER_COMPANY = 'SIGNER_COMPANY';
    const CONTENT_TYPE_SIGNATURE_DATE = 'SIGNATURE_DATE';
    const CONTENT_TYPE_AGREEMENT_NAME = 'AGREEMENT_NAME';
    const CONTENT_TYPE_AGREEMENT_MESSAGE = 'AGREEMENT_MESSAGE';
    const CONTENT_TYPE_TRANSACTION_ID = 'TRANSACTION_ID';
    const CONTENT_TYPE_SIGNATURE_STAMP = 'SIGNATURE_STAMP';
    const CONTENT_TYPE_PAYMENT = 'PAYMENT';
    const CONTENT_TYPE_DIGITAL_SIGNATURE = 'DIGITAL_SIGNATURE';
    const VALIDATION_NONE = 'NONE';
    const VALIDATION_STRING = 'STRING';
    const VALIDATION_NUMBER = 'NUMBER';
    const VALIDATION_DATE = 'DATE';
    const VALIDATION_DATE_CUSTOM = 'DATE_CUSTOM';
    const VALIDATION_TIME = 'TIME';
    const VALIDATION_ZIP = 'ZIP';
    const VALIDATION_PHONE = 'PHONE';
    const VALIDATION_SOCIAL_SEC = 'SOCIAL_SEC';
    const VALIDATION_EMAIL = 'EMAIL';
    const VALIDATION_CURRENCY = 'CURRENCY';
    const VALIDATION_PERCENT = 'PERCENT';
    const VALIDATION_FORMULA = 'FORMULA';
    const VALIDATION_CUSTOM = 'CUSTOM';
    const VALIDATION_XFA_PICTURE = 'XFA_PICTURE';
    const DISPLAY_FORMAT_TYPE__DEFAULT = 'DEFAULT';
    const DISPLAY_FORMAT_TYPE_DATE = 'DATE';
    const DISPLAY_FORMAT_TYPE_NUMBER = 'NUMBER';
    const ALIGNMENT_LEFT = 'LEFT';
    const ALIGNMENT_RIGHT = 'RIGHT';
    const ALIGNMENT_CENTER = 'CENTER';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getRadioCheckTypeAllowableValues()
    {
        return [
            self::RADIO_CHECK_TYPE_CIRCLE,
            self::RADIO_CHECK_TYPE_CHECK,
            self::RADIO_CHECK_TYPE_CROSS,
            self::RADIO_CHECK_TYPE_DIAMOND,
            self::RADIO_CHECK_TYPE_SQUARE,
            self::RADIO_CHECK_TYPE_STAR,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getOriginAllowableValues()
    {
        return [
            self::ORIGIN_AUTHORED,
            self::ORIGIN_GENERATED,
            self::ORIGIN_IMPORTED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getInputTypeAllowableValues()
    {
        return [
            self::INPUT_TYPE_TEXT_FIELD,
            self::INPUT_TYPE_MULTILINE,
            self::INPUT_TYPE_PASSWORD,
            self::INPUT_TYPE_RADIO,
            self::INPUT_TYPE_CHECKBOX,
            self::INPUT_TYPE_DROP_DOWN,
            self::INPUT_TYPE_LISTBOX,
            self::INPUT_TYPE_SIGNATURE,
            self::INPUT_TYPE_PDF_SIGNATURE,
            self::INPUT_TYPE_BUTTON,
            self::INPUT_TYPE_BLOCK,
            self::INPUT_TYPE_FILE_CHOOSER,
            self::INPUT_TYPE_COMB,
            self::INPUT_TYPE_INLINE_IMAGE,
            self::INPUT_TYPE_UNSUPPORTED,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getBorderStyleAllowableValues()
    {
        return [
            self::BORDER_STYLE_SOLID,
            self::BORDER_STYLE_DASHED,
            self::BORDER_STYLE_BEVELED,
            self::BORDER_STYLE_INSET,
            self::BORDER_STYLE_UNDERLINE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getContentTypeAllowableValues()
    {
        return [
            self::CONTENT_TYPE_DATA,
            self::CONTENT_TYPE_SIGNATURE_BLOCK,
            self::CONTENT_TYPE_SIGNATURE,
            self::CONTENT_TYPE_SIGNER_NAME,
            self::CONTENT_TYPE_SIGNER_FIRST_NAME,
            self::CONTENT_TYPE_SIGNER_LAST_NAME,
            self::CONTENT_TYPE_SIGNER_INITIALS,
            self::CONTENT_TYPE_SIGNER_EMAIL,
            self::CONTENT_TYPE_SIGNER_TITLE,
            self::CONTENT_TYPE_SIGNER_COMPANY,
            self::CONTENT_TYPE_SIGNATURE_DATE,
            self::CONTENT_TYPE_AGREEMENT_NAME,
            self::CONTENT_TYPE_AGREEMENT_MESSAGE,
            self::CONTENT_TYPE_TRANSACTION_ID,
            self::CONTENT_TYPE_SIGNATURE_STAMP,
            self::CONTENT_TYPE_PAYMENT,
            self::CONTENT_TYPE_DIGITAL_SIGNATURE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getValidationAllowableValues()
    {
        return [
            self::VALIDATION_NONE,
            self::VALIDATION_STRING,
            self::VALIDATION_NUMBER,
            self::VALIDATION_DATE,
            self::VALIDATION_DATE_CUSTOM,
            self::VALIDATION_TIME,
            self::VALIDATION_ZIP,
            self::VALIDATION_PHONE,
            self::VALIDATION_SOCIAL_SEC,
            self::VALIDATION_EMAIL,
            self::VALIDATION_CURRENCY,
            self::VALIDATION_PERCENT,
            self::VALIDATION_FORMULA,
            self::VALIDATION_CUSTOM,
            self::VALIDATION_XFA_PICTURE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getDisplayFormatTypeAllowableValues()
    {
        return [
            self::DISPLAY_FORMAT_TYPE__DEFAULT,
            self::DISPLAY_FORMAT_TYPE_DATE,
            self::DISPLAY_FORMAT_TYPE_NUMBER,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getAlignmentAllowableValues()
    {
        return [
            self::ALIGNMENT_LEFT,
            self::ALIGNMENT_RIGHT,
            self::ALIGNMENT_CENTER,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['radio_check_type'] = isset($data['radio_check_type']) ? $data['radio_check_type'] : null;
        $this->container['border_color'] = isset($data['border_color']) ? $data['border_color'] : null;
        $this->container['value_expression'] = isset($data['value_expression']) ? $data['value_expression'] : null;
        $this->container['masking_text'] = isset($data['masking_text']) ? $data['masking_text'] : null;
        $this->container['default_value'] = isset($data['default_value']) ? $data['default_value'] : null;
        $this->container['masked'] = isset($data['masked']) ? $data['masked'] : null;
        $this->container['min_length'] = isset($data['min_length']) ? $data['min_length'] : null;
        $this->container['origin'] = isset($data['origin']) ? $data['origin'] : null;
        $this->container['tooltip'] = isset($data['tooltip']) ? $data['tooltip'] : null;
        $this->container['hidden_options'] = isset($data['hidden_options']) ? $data['hidden_options'] : null;
        $this->container['required'] = isset($data['required']) ? $data['required'] : null;
        $this->container['validation_data'] = isset($data['validation_data']) ? $data['validation_data'] : null;
        $this->container['min_value'] = isset($data['min_value']) ? $data['min_value'] : null;
        $this->container['border_width'] = isset($data['border_width']) ? $data['border_width'] : null;
        $this->container['url_overridable'] = isset($data['url_overridable']) ? $data['url_overridable'] : null;
        $this->container['input_type'] = isset($data['input_type']) ? $data['input_type'] : null;
        $this->container['border_style'] = isset($data['border_style']) ? $data['border_style'] : null;
        $this->container['calculated'] = isset($data['calculated']) ? $data['calculated'] : null;
        $this->container['content_type'] = isset($data['content_type']) ? $data['content_type'] : null;
        $this->container['validation'] = isset($data['validation']) ? $data['validation'] : null;
        $this->container['display_label'] = isset($data['display_label']) ? $data['display_label'] : null;
        $this->container['hyperlink'] = isset($data['hyperlink']) ? $data['hyperlink'] : null;
        $this->container['background_color'] = isset($data['background_color']) ? $data['background_color'] : null;
        $this->container['visible'] = isset($data['visible']) ? $data['visible'] : null;
        $this->container['display_format_type'] = isset($data['display_format_type']) ? $data['display_format_type'] : null;
        $this->container['max_value'] = isset($data['max_value']) ? $data['max_value'] : null;
        $this->container['validation_err_msg'] = isset($data['validation_err_msg']) ? $data['validation_err_msg'] : null;
        $this->container['display_format'] = isset($data['display_format']) ? $data['display_format'] : null;
        $this->container['visible_options'] = isset($data['visible_options']) ? $data['visible_options'] : null;
        $this->container['read_only'] = isset($data['read_only']) ? $data['read_only'] : null;
        $this->container['font_name'] = isset($data['font_name']) ? $data['font_name'] : null;
        $this->container['conditional_action'] = isset($data['conditional_action']) ? $data['conditional_action'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['font_size'] = isset($data['font_size']) ? $data['font_size'] : null;
        $this->container['locations'] = isset($data['locations']) ? $data['locations'] : null;
        $this->container['assignee'] = isset($data['assignee']) ? $data['assignee'] : null;
        $this->container['alignment'] = isset($data['alignment']) ? $data['alignment'] : null;
        $this->container['font_color'] = isset($data['font_color']) ? $data['font_color'] : null;
        $this->container['max_length'] = isset($data['max_length']) ? $data['max_length'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getRadioCheckTypeAllowableValues();
        if (!is_null($this->container['radio_check_type']) && !in_array($this->container['radio_check_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'radio_check_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getOriginAllowableValues();
        if (!is_null($this->container['origin']) && !in_array($this->container['origin'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'origin', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getInputTypeAllowableValues();
        if (!is_null($this->container['input_type']) && !in_array($this->container['input_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'input_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getBorderStyleAllowableValues();
        if (!is_null($this->container['border_style']) && !in_array($this->container['border_style'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'border_style', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getContentTypeAllowableValues();
        if (!is_null($this->container['content_type']) && !in_array($this->container['content_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'content_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getValidationAllowableValues();
        if (!is_null($this->container['validation']) && !in_array($this->container['validation'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'validation', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getDisplayFormatTypeAllowableValues();
        if (!is_null($this->container['display_format_type']) && !in_array($this->container['display_format_type'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'display_format_type', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getAlignmentAllowableValues();
        if (!is_null($this->container['alignment']) && !in_array($this->container['alignment'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'alignment', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets radio_check_type
     *
     * @return string
     */
    public function getRadioCheckType()
    {
        return $this->container['radio_check_type'];
    }

    /**
     * Sets radio_check_type
     *
     * @param string $radio_check_type The type of radio button (if field is radio button, identified by inputType).
     *
     * @return $this
     */
    public function setRadioCheckType($radio_check_type)
    {
        $allowedValues = $this->getRadioCheckTypeAllowableValues();
        if (!is_null($radio_check_type) && !in_array($radio_check_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'radio_check_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['radio_check_type'] = $radio_check_type;

        return $this;
    }

    /**
     * Gets border_color
     *
     * @return string
     */
    public function getBorderColor()
    {
        return $this->container['border_color'];
    }

    /**
     * Sets border_color
     *
     * @param string $border_color Color of the border of the field in RGB or HEX format
     *
     * @return $this
     */
    public function setBorderColor($border_color)
    {
        $this->container['border_color'] = $border_color;

        return $this;
    }

    /**
     * Gets value_expression
     *
     * @return string
     */
    public function getValueExpression()
    {
        return $this->container['value_expression'];
    }

    /**
     * Sets value_expression
     *
     * @param string $value_expression Expression to calculate value of the form field
     *
     * @return $this
     */
    public function setValueExpression($value_expression)
    {
        $this->container['value_expression'] = $value_expression;

        return $this;
    }

    /**
     * Gets masking_text
     *
     * @return string
     */
    public function getMaskingText()
    {
        return $this->container['masking_text'];
    }

    /**
     * Sets masking_text
     *
     * @param string $masking_text Text to mask the masked form field
     *
     * @return $this
     */
    public function setMaskingText($masking_text)
    {
        $this->container['masking_text'] = $masking_text;

        return $this;
    }

    /**
     * Gets default_value
     *
     * @return string
     */
    public function getDefaultValue()
    {
        return $this->container['default_value'];
    }

    /**
     * Sets default_value
     *
     * @param string $default_value Default value of the form field
     *
     * @return $this
     */
    public function setDefaultValue($default_value)
    {
        $this->container['default_value'] = $default_value;

        return $this;
    }

    /**
     * Gets masked
     *
     * @return bool
     */
    public function getMasked()
    {
        return $this->container['masked'];
    }

    /**
     * Sets masked
     *
     * @param bool $masked true if the input entered by the signer has to be masked (like password), false if it shouldn't be
     *
     * @return $this
     */
    public function setMasked($masked)
    {
        $this->container['masked'] = $masked;

        return $this;
    }

    /**
     * Gets min_length
     *
     * @return int
     */
    public function getMinLength()
    {
        return $this->container['min_length'];
    }

    /**
     * Sets min_length
     *
     * @param int $min_length Minimum length of the input text field in terms of no. of characters
     *
     * @return $this
     */
    public function setMinLength($min_length)
    {
        $this->container['min_length'] = $min_length;

        return $this;
    }

    /**
     * Gets origin
     *
     * @return string
     */
    public function getOrigin()
    {
        return $this->container['origin'];
    }

    /**
     * Sets origin
     *
     * @param string $origin Origin of Form Field
     *
     * @return $this
     */
    public function setOrigin($origin)
    {
        $allowedValues = $this->getOriginAllowableValues();
        if (!is_null($origin) && !in_array($origin, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'origin', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['origin'] = $origin;

        return $this;
    }

    /**
     * Gets tooltip
     *
     * @return string
     */
    public function getTooltip()
    {
        return $this->container['tooltip'];
    }

    /**
     * Sets tooltip
     *
     * @param string $tooltip Text that appears while hovering over the field
     *
     * @return $this
     */
    public function setTooltip($tooltip)
    {
        $this->container['tooltip'] = $tooltip;

        return $this;
    }

    /**
     * Gets hidden_options
     *
     * @return string[]
     */
    public function getHiddenOptions()
    {
        return $this->container['hidden_options'];
    }

    /**
     * Sets hidden_options
     *
     * @param string[] $hidden_options Text values which are hidden in a drop down form field
     *
     * @return $this
     */
    public function setHiddenOptions($hidden_options)
    {
        $this->container['hidden_options'] = $hidden_options;

        return $this;
    }

    /**
     * Gets required
     *
     * @return bool
     */
    public function getRequired()
    {
        return $this->container['required'];
    }

    /**
     * Sets required
     *
     * @param bool $required true if it is a mandatory field to be filled by the signer, else false
     *
     * @return $this
     */
    public function setRequired($required)
    {
        $this->container['required'] = $required;

        return $this;
    }

    /**
     * Gets validation_data
     *
     * @return string
     */
    public function getValidationData()
    {
        return $this->container['validation_data'];
    }

    /**
     * Sets validation_data
     *
     * @param string $validation_data Further data for validating input with regards to the field's specified format. The contents and interpretation of formatData depends on the value of validation.
     *
     * @return $this
     */
    public function setValidationData($validation_data)
    {
        $this->container['validation_data'] = $validation_data;

        return $this;
    }

    /**
     * Gets min_value
     *
     * @return double
     */
    public function getMinValue()
    {
        return $this->container['min_value'];
    }

    /**
     * Sets min_value
     *
     * @param double $min_value Lower bound of the number that can be entered by the signer
     *
     * @return $this
     */
    public function setMinValue($min_value)
    {
        $this->container['min_value'] = $min_value;

        return $this;
    }

    /**
     * Gets border_width
     *
     * @return double
     */
    public function getBorderWidth()
    {
        return $this->container['border_width'];
    }

    /**
     * Sets border_width
     *
     * @param double $border_width Width of the border of the field in pixels
     *
     * @return $this
     */
    public function setBorderWidth($border_width)
    {
        $this->container['border_width'] = $border_width;

        return $this;
    }

    /**
     * Gets url_overridable
     *
     * @return bool
     */
    public function getUrlOverridable()
    {
        return $this->container['url_overridable'];
    }

    /**
     * Sets url_overridable
     *
     * @param bool $url_overridable For widget text fields only - true if the default value may come from the URL, else false
     *
     * @return $this
     */
    public function setUrlOverridable($url_overridable)
    {
        $this->container['url_overridable'] = $url_overridable;

        return $this;
    }

    /**
     * Gets input_type
     *
     * @return string
     */
    public function getInputType()
    {
        return $this->container['input_type'];
    }

    /**
     * Sets input_type
     *
     * @param string $input_type Input type of the form field
     *
     * @return $this
     */
    public function setInputType($input_type)
    {
        $allowedValues = $this->getInputTypeAllowableValues();
        if (!is_null($input_type) && !in_array($input_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'input_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['input_type'] = $input_type;

        return $this;
    }

    /**
     * Gets border_style
     *
     * @return string
     */
    public function getBorderStyle()
    {
        return $this->container['border_style'];
    }

    /**
     * Sets border_style
     *
     * @param string $border_style Style of the border of the field.
     *
     * @return $this
     */
    public function setBorderStyle($border_style)
    {
        $allowedValues = $this->getBorderStyleAllowableValues();
        if (!is_null($border_style) && !in_array($border_style, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'border_style', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['border_style'] = $border_style;

        return $this;
    }

    /**
     * Gets calculated
     *
     * @return bool
     */
    public function getCalculated()
    {
        return $this->container['calculated'];
    }

    /**
     * Sets calculated
     *
     * @param bool $calculated true if this field's value is calculated from an expression, else false
     *
     * @return $this
     */
    public function setCalculated($calculated)
    {
        $this->container['calculated'] = $calculated;

        return $this;
    }

    /**
     * Gets content_type
     *
     * @return string
     */
    public function getContentType()
    {
        return $this->container['content_type'];
    }

    /**
     * Sets content_type
     *
     * @param string $content_type Content Type of the form field.
     *
     * @return $this
     */
    public function setContentType($content_type)
    {
        $allowedValues = $this->getContentTypeAllowableValues();
        if (!is_null($content_type) && !in_array($content_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'content_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['content_type'] = $content_type;

        return $this;
    }

    /**
     * Gets validation
     *
     * @return string
     */
    public function getValidation()
    {
        return $this->container['validation'];
    }

    /**
     * Sets validation
     *
     * @param string $validation Rule for validating the field value.
     *
     * @return $this
     */
    public function setValidation($validation)
    {
        $allowedValues = $this->getValidationAllowableValues();
        if (!is_null($validation) && !in_array($validation, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'validation', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['validation'] = $validation;

        return $this;
    }

    /**
     * Gets display_label
     *
     * @return string
     */
    public function getDisplayLabel()
    {
        return $this->container['display_label'];
    }

    /**
     * Sets display_label
     *
     * @param string $display_label Display label attached to the field
     *
     * @return $this
     */
    public function setDisplayLabel($display_label)
    {
        $this->container['display_label'] = $display_label;

        return $this;
    }

    /**
     * Gets hyperlink
     *
     * @return \Adobe\ESign\Agreements\Model\FormFieldHyperlink
     */
    public function getHyperlink()
    {
        return $this->container['hyperlink'];
    }

    /**
     * Sets hyperlink
     *
     * @param \Adobe\ESign\Agreements\Model\FormFieldHyperlink $hyperlink Hyperlink-specific data (e.g. as url, link type)
     *
     * @return $this
     */
    public function setHyperlink($hyperlink)
    {
        $this->container['hyperlink'] = $hyperlink;

        return $this;
    }

    /**
     * Gets background_color
     *
     * @return string
     */
    public function getBackgroundColor()
    {
        return $this->container['background_color'];
    }

    /**
     * Sets background_color
     *
     * @param string $background_color Background color of the form field in RGB or HEX format
     *
     * @return $this
     */
    public function setBackgroundColor($background_color)
    {
        $this->container['background_color'] = $background_color;

        return $this;
    }

    /**
     * Gets visible
     *
     * @return bool
     */
    public function getVisible()
    {
        return $this->container['visible'];
    }

    /**
     * Sets visible
     *
     * @param bool $visible If set to false, then the form field is hidden.  Otherwise, it is visible.
     *
     * @return $this
     */
    public function setVisible($visible)
    {
        $this->container['visible'] = $visible;

        return $this;
    }

    /**
     * Gets display_format_type
     *
     * @return string
     */
    public function getDisplayFormatType()
    {
        return $this->container['display_format_type'];
    }

    /**
     * Sets display_format_type
     *
     * @param string $display_format_type Format type of the text field.
     *
     * @return $this
     */
    public function setDisplayFormatType($display_format_type)
    {
        $allowedValues = $this->getDisplayFormatTypeAllowableValues();
        if (!is_null($display_format_type) && !in_array($display_format_type, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'display_format_type', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['display_format_type'] = $display_format_type;

        return $this;
    }

    /**
     * Gets max_value
     *
     * @return double
     */
    public function getMaxValue()
    {
        return $this->container['max_value'];
    }

    /**
     * Sets max_value
     *
     * @param double $max_value Upper bound of the number that can be entered by the signer
     *
     * @return $this
     */
    public function setMaxValue($max_value)
    {
        $this->container['max_value'] = $max_value;

        return $this;
    }

    /**
     * Gets validation_err_msg
     *
     * @return string
     */
    public function getValidationErrMsg()
    {
        return $this->container['validation_err_msg'];
    }

    /**
     * Sets validation_err_msg
     *
     * @param string $validation_err_msg Error message to be shown to the signer if filled value doesn't match the validations of the form field
     *
     * @return $this
     */
    public function setValidationErrMsg($validation_err_msg)
    {
        $this->container['validation_err_msg'] = $validation_err_msg;

        return $this;
    }

    /**
     * Gets display_format
     *
     * @return string
     */
    public function getDisplayFormat()
    {
        return $this->container['display_format'];
    }

    /**
     * Sets display_format
     *
     * @param string $display_format Format of the value of the field to be displayed based on the displayFormatType property.
     *
     * @return $this
     */
    public function setDisplayFormat($display_format)
    {
        $this->container['display_format'] = $display_format;

        return $this;
    }

    /**
     * Gets visible_options
     *
     * @return string[]
     */
    public function getVisibleOptions()
    {
        return $this->container['visible_options'];
    }

    /**
     * Sets visible_options
     *
     * @param string[] $visible_options Text values which are visible in a drop down form field
     *
     * @return $this
     */
    public function setVisibleOptions($visible_options)
    {
        $this->container['visible_options'] = $visible_options;

        return $this;
    }

    /**
     * Gets read_only
     *
     * @return bool
     */
    public function getReadOnly()
    {
        return $this->container['read_only'];
    }

    /**
     * Sets read_only
     *
     * @param bool $read_only true if it is a read-only field, else false
     *
     * @return $this
     */
    public function setReadOnly($read_only)
    {
        $this->container['read_only'] = $read_only;

        return $this;
    }

    /**
     * Gets font_name
     *
     * @return string
     */
    public function getFontName()
    {
        return $this->container['font_name'];
    }

    /**
     * Sets font_name
     *
     * @param string $font_name Font name of the form field
     *
     * @return $this
     */
    public function setFontName($font_name)
    {
        $this->container['font_name'] = $font_name;

        return $this;
    }

    /**
     * Gets conditional_action
     *
     * @return \Adobe\ESign\Agreements\Model\FormFieldConditionalAction
     */
    public function getConditionalAction()
    {
        return $this->container['conditional_action'];
    }

    /**
     * Sets conditional_action
     *
     * @param \Adobe\ESign\Agreements\Model\FormFieldConditionalAction $conditional_action A predicate (or set of predicates) that determines whether this field is visible and enabled.
     *
     * @return $this
     */
    public function setConditionalAction($conditional_action)
    {
        $this->container['conditional_action'] = $conditional_action;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name of the form field
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets font_size
     *
     * @return double
     */
    public function getFontSize()
    {
        return $this->container['font_size'];
    }

    /**
     * Sets font_size
     *
     * @param double $font_size Font size of the form field in points
     *
     * @return $this
     */
    public function setFontSize($font_size)
    {
        $this->container['font_size'] = $font_size;

        return $this;
    }

    /**
     * Gets locations
     *
     * @return \Adobe\ESign\Agreements\Model\FormFieldLocation[]
     */
    public function getLocations()
    {
        return $this->container['locations'];
    }

    /**
     * Sets locations
     *
     * @param \Adobe\ESign\Agreements\Model\FormFieldLocation[] $locations All locations in a document where the form field is placed
     *
     * @return $this
     */
    public function setLocations($locations)
    {
        $this->container['locations'] = $locations;

        return $this;
    }

    /**
     * Gets assignee
     *
     * @return string
     */
    public function getAssignee()
    {
        return $this->container['assignee'];
    }

    /**
     * Sets assignee
     *
     * @param string $assignee Who the field is assigned to.  Either a participant set id, null, NOBODY or PREFILL.
     *
     * @return $this
     */
    public function setAssignee($assignee)
    {
        $this->container['assignee'] = $assignee;

        return $this;
    }

    /**
     * Gets alignment
     *
     * @return string
     */
    public function getAlignment()
    {
        return $this->container['alignment'];
    }

    /**
     * Sets alignment
     *
     * @param string $alignment Alignment of the text.
     *
     * @return $this
     */
    public function setAlignment($alignment)
    {
        $allowedValues = $this->getAlignmentAllowableValues();
        if (!is_null($alignment) && !in_array($alignment, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'alignment', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['alignment'] = $alignment;

        return $this;
    }

    /**
     * Gets font_color
     *
     * @return string
     */
    public function getFontColor()
    {
        return $this->container['font_color'];
    }

    /**
     * Sets font_color
     *
     * @param string $font_color Font color of the form field in RGB or HEX format
     *
     * @return $this
     */
    public function setFontColor($font_color)
    {
        $this->container['font_color'] = $font_color;

        return $this;
    }

    /**
     * Gets max_length
     *
     * @return int
     */
    public function getMaxLength()
    {
        return $this->container['max_length'];
    }

    /**
     * Sets max_length
     *
     * @param int $max_length Maximum length of the input text field in terms of no. of characters
     *
     * @return $this
     */
    public function setMaxLength($max_length)
    {
        $this->container['max_length'] = $max_length;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


