<?php
/**
 * LibraryDocumentInfo
 *
 * PHP version 5
 *
 * @category Class
 * @package  Adobe\ESign\LibraryDocuments
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: 6.0.0
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.0
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Adobe\ESign\LibraryDocuments\Model;

use \ArrayAccess;
use \Adobe\ESign\LibraryDocuments\ObjectSerializer;

/**
 * LibraryDocumentInfo Class Doc Comment
 *
 * @category Class
 * @package  Adobe\ESign\LibraryDocuments
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LibraryDocumentInfo implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'LibraryDocumentInfo';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'created_date' => '\DateTime',
        'template_types' => 'string[]',
        'creator_email' => 'string',
        'sharing_mode' => 'string',
        'creator_name' => 'string',
        'modified_date' => '\DateTime',
        'name' => 'string',
        'file_infos' => '\Adobe\ESign\LibraryDocuments\Model\FileInfo[]',
        'id' => 'string',
        'state' => 'string',
        'status' => 'string'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'created_date' => 'date',
        'template_types' => null,
        'creator_email' => null,
        'sharing_mode' => null,
        'creator_name' => null,
        'modified_date' => 'date',
        'name' => null,
        'file_infos' => null,
        'id' => null,
        'state' => null,
        'status' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'created_date' => 'createdDate',
        'template_types' => 'templateTypes',
        'creator_email' => 'creatorEmail',
        'sharing_mode' => 'sharingMode',
        'creator_name' => 'creatorName',
        'modified_date' => 'modifiedDate',
        'name' => 'name',
        'file_infos' => 'fileInfos',
        'id' => 'id',
        'state' => 'state',
        'status' => 'status'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'created_date' => 'setCreatedDate',
        'template_types' => 'setTemplateTypes',
        'creator_email' => 'setCreatorEmail',
        'sharing_mode' => 'setSharingMode',
        'creator_name' => 'setCreatorName',
        'modified_date' => 'setModifiedDate',
        'name' => 'setName',
        'file_infos' => 'setFileInfos',
        'id' => 'setId',
        'state' => 'setState',
        'status' => 'setStatus'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'created_date' => 'getCreatedDate',
        'template_types' => 'getTemplateTypes',
        'creator_email' => 'getCreatorEmail',
        'sharing_mode' => 'getSharingMode',
        'creator_name' => 'getCreatorName',
        'modified_date' => 'getModifiedDate',
        'name' => 'getName',
        'file_infos' => 'getFileInfos',
        'id' => 'getId',
        'state' => 'getState',
        'status' => 'getStatus'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const TEMPLATE_TYPES_DOCUMENT = 'DOCUMENT';
    const TEMPLATE_TYPES_FORM_FIELD_LAYER = 'FORM_FIELD_LAYER';
    const SHARING_MODE_USER = 'USER';
    const SHARING_MODE_GROUP = 'GROUP';
    const SHARING_MODE_ACCOUNT = 'ACCOUNT';
    const SHARING_MODE__GLOBAL = 'GLOBAL';
    const STATE_AUTHORING = 'AUTHORING';
    const STATE_ACTIVE = 'ACTIVE';
    const STATUS_AUTHORING = 'AUTHORING';
    const STATUS_ACTIVE = 'ACTIVE';
    const STATUS_REMOVED = 'REMOVED';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getTemplateTypesAllowableValues()
    {
        return [
            self::TEMPLATE_TYPES_DOCUMENT,
            self::TEMPLATE_TYPES_FORM_FIELD_LAYER,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getSharingModeAllowableValues()
    {
        return [
            self::SHARING_MODE_USER,
            self::SHARING_MODE_GROUP,
            self::SHARING_MODE_ACCOUNT,
            self::SHARING_MODE__GLOBAL,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_AUTHORING,
            self::STATE_ACTIVE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getStatusAllowableValues()
    {
        return [
            self::STATUS_AUTHORING,
            self::STATUS_ACTIVE,
            self::STATUS_REMOVED,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['created_date'] = isset($data['created_date']) ? $data['created_date'] : null;
        $this->container['template_types'] = isset($data['template_types']) ? $data['template_types'] : null;
        $this->container['creator_email'] = isset($data['creator_email']) ? $data['creator_email'] : null;
        $this->container['sharing_mode'] = isset($data['sharing_mode']) ? $data['sharing_mode'] : null;
        $this->container['creator_name'] = isset($data['creator_name']) ? $data['creator_name'] : null;
        $this->container['modified_date'] = isset($data['modified_date']) ? $data['modified_date'] : null;
        $this->container['name'] = isset($data['name']) ? $data['name'] : null;
        $this->container['file_infos'] = isset($data['file_infos']) ? $data['file_infos'] : null;
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['status'] = isset($data['status']) ? $data['status'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        $allowedValues = $this->getSharingModeAllowableValues();
        if (!is_null($this->container['sharing_mode']) && !in_array($this->container['sharing_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'sharing_mode', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($this->container['state']) && !in_array($this->container['state'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'state', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($this->container['status']) && !in_array($this->container['status'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'status', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets created_date
     *
     * @return \DateTime
     */
    public function getCreatedDate()
    {
        return $this->container['created_date'];
    }

    /**
     * Sets created_date
     *
     * @param \DateTime $created_date Date when library document was created. It will be ignored in POST/PUT requests. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time
     *
     * @return $this
     */
    public function setCreatedDate($created_date)
    {
        $this->container['created_date'] = $created_date;

        return $this;
    }

    /**
     * Gets template_types
     *
     * @return string[]
     */
    public function getTemplateTypes()
    {
        return $this->container['template_types'];
    }

    /**
     * Sets template_types
     *
     * @param string[] $template_types A list of one or more library template types
     *
     * @return $this
     */
    public function setTemplateTypes($template_types)
    {
        $allowedValues = $this->getTemplateTypesAllowableValues();
        if (!is_null($template_types) && array_diff($template_types, $allowedValues)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'template_types', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['template_types'] = $template_types;

        return $this;
    }

    /**
     * Gets creator_email
     *
     * @return string
     */
    public function getCreatorEmail()
    {
        return $this->container['creator_email'];
    }

    /**
     * Sets creator_email
     *
     * @param string $creator_email Email address of the library document creator. It will be ignored in POST/PUT requests
     *
     * @return $this
     */
    public function setCreatorEmail($creator_email)
    {
        $this->container['creator_email'] = $creator_email;

        return $this;
    }

    /**
     * Gets sharing_mode
     *
     * @return string
     */
    public function getSharingMode()
    {
        return $this->container['sharing_mode'];
    }

    /**
     * Sets sharing_mode
     *
     * @param string $sharing_mode Specifies who should have access to this library document. GLOBAL sharing mode is not applicable in POST/PUT requests
     *
     * @return $this
     */
    public function setSharingMode($sharing_mode)
    {
        $allowedValues = $this->getSharingModeAllowableValues();
        if (!is_null($sharing_mode) && !in_array($sharing_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'sharing_mode', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['sharing_mode'] = $sharing_mode;

        return $this;
    }

    /**
     * Gets creator_name
     *
     * @return string
     */
    public function getCreatorName()
    {
        return $this->container['creator_name'];
    }

    /**
     * Sets creator_name
     *
     * @param string $creator_name Name of the library document creator.  It will be ignored in POST/PUT requests
     *
     * @return $this
     */
    public function setCreatorName($creator_name)
    {
        $this->container['creator_name'] = $creator_name;

        return $this;
    }

    /**
     * Gets modified_date
     *
     * @return \DateTime
     */
    public function getModifiedDate()
    {
        return $this->container['modified_date'];
    }

    /**
     * Sets modified_date
     *
     * @param \DateTime $modified_date Date when library document was last modified. It will be ignored in POST/PUT requests. Format would be yyyy-MM-dd'T'HH:mm:ssZ. For example, e.g 2016-02-25T18:46:19Z represents UTC time
     *
     * @return $this
     */
    public function setModifiedDate($modified_date)
    {
        $this->container['modified_date'] = $modified_date;

        return $this;
    }

    /**
     * Gets name
     *
     * @return string
     */
    public function getName()
    {
        return $this->container['name'];
    }

    /**
     * Sets name
     *
     * @param string $name The name of the library template that will be used to identify it, in emails and on the website
     *
     * @return $this
     */
    public function setName($name)
    {
        $this->container['name'] = $name;

        return $this;
    }

    /**
     * Gets file_infos
     *
     * @return \Adobe\ESign\LibraryDocuments\Model\FileInfo[]
     */
    public function getFileInfos()
    {
        return $this->container['file_infos'];
    }

    /**
     * Sets file_infos
     *
     * @param \Adobe\ESign\LibraryDocuments\Model\FileInfo[] $file_infos A list of one or more files (or references to files) that will be used to create the template. If more than one file is provided, they will be combined into one PDF. Note: Only a single parameter in every FileInfo object must be specified
     *
     * @return $this
     */
    public function setFileInfos($file_infos)
    {
        $this->container['file_infos'] = $file_infos;

        return $this;
    }

    /**
     * Gets id
     *
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param string $id The unique identifier that is used to refer to the library template. It will be ignored in POST requests
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets state
     *
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     *
     * @param string $state State of the library document.
     *
     * @return $this
     */
    public function setState($state)
    {
        $allowedValues = $this->getStateAllowableValues();
        if (!is_null($state) && !in_array($state, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'state', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets status
     *
     * @return string
     */
    public function getStatus()
    {
        return $this->container['status'];
    }

    /**
     * Sets status
     *
     * @param string $status Status of the library document
     *
     * @return $this
     */
    public function setStatus($status)
    {
        $allowedValues = $this->getStatusAllowableValues();
        if (!is_null($status) && !in_array($status, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'status', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['status'] = $status;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


